Import("env")
import pdb
import SCons.Util, SCons.Subst
import SconsUtils.utils as utils
import re

nenv = env.Clone()

nenv.Append(CFLAGS = "-include lib/config.h -Ilibraptor/ -DBUILDING_DLL -fvisibility=hidden ")

source_files = """
#lib/class.c #lib/talloc.c
#lib/misc.c #lib/zip.c #lib/stringio.c #lib/resolver.c
#lib/rdf.c  #lib/image.c #lib/map.c
#lib/encode.c #lib/queue.c
#lib/graph.c #lib/error.c
#libreplace/replace.c
#lib/public.c
"""

## Optional support for EWF and AFF1 volumes
if utils.HEADERS.get("HAVE_LIBEWF_H"):
    source_files += "  #lib/ewfvolume.c "

if utils.HEADERS.get("HAVE_OPENSSL"):
    source_files += "  #lib/encrypt.c "

uuid_files = """
#uuid/clear.c    #uuid/copy.c      #uuid/gen_uuid_nt.c  #uuid/pack.c
#uuid/unparse.c
#uuid/compare.c  #uuid/gen_uuid.c  #uuid/isnull.c       #uuid/parse.c
#uuid/unpack.c   #uuid/uuid_time.c
"""

## We compile these statically into our library to ensure users dont
## need tdb as a dependency and also to ensure we can port tdb for
## windows.
tdb_files = """
#libtdb/dump.c   #libtdb/freelist.c       #libtdb/io.c    #libtdb/open.c
#libtdb/transaction.c
#libtdb/error.c  #libtdb/freelistcheck.c  #libtdb/lock.c  #libtdb/tdb.c
#libtdb/traverse.c
"""

nenv.Append(CPPFLAGS = ['-Ilibreplace/'], CFLAGS=" -DNO_CONFIG_H")

env.libaff4_sources =  Split(uuid_files + source_files + " #lib/init.c " +
                             tdb_files) + env.libraptor_objs

## Autogenerate initialization functions for all classes
def generate_init_functions(target, source, env):
    class_initialisers = ''
    privates = set()
    module_inits = []
    for s in source:
        for line in open(s.path):
            m = re.search("CLASS\(([^,]+)", line)
            if m:
                privates.add(m.group(1))

            m = re.search("AFF4_MODULE_INIT\(([^\)]+)", line)
            if m:
                module_inits.append(m.group(1))
                continue

            m = re.search("VIRTUAL\(([^,]+)", line)
            if m and m.group(1) not in privates:
                class_initialisers += "%s_init((Object)&__%s);\n" % (m.group(1),m.group(1))

    module_inits.sort()
    data = """
/** This file is autogenerated by the build system.

We incorporate initialization functions for all plugins registered.
*/
#include "aff4.h"

// initialiser prototypes
%(init_prototypes)s

void __attribute ((constructor)) _init_aff4_library (void) {
%(class_initialisers)s

// Module Initialisers
%(init)s
};
""" % dict(init_prototypes = '\n'.join(['void %s_init();' % x for x in module_inits]),
           class_initialisers = class_initialisers,
           init = '\n'.join(['%s_init();' % x for x in module_inits]))

    fd = open(target[0].path,"w")
    fd.write(data)
    fd.close()

env.Command("#lib/init.c",
            Split(source_files),
            env.Action(generate_init_functions,
                       utils.warn("Generating init functions")))

env.libaff4_so = library = nenv.VersionedSharedLibrary("aff4", '0', env.libaff4_sources)

env.installed_libaff4_so = nenv.InstallVersionedSharedLibrary("${prefix}/lib/", library)
utils.install_target = nenv.Alias('install', '${prefix}')

#utils.libaff4_static_lib = nenv.StaticLibrary('aff4', env.libaff4_sources)
