
/**********************************************************************
     Autogenerated module pyregfi

This module was autogenerated from the following files:
/usr/local/include/regfi/regfi.h
/home/mic/projects/aff4/python2.6/regfi/pyregfi.h

This module implements the following classes:
Module pyregfi
    # Value structure
 * @ingroup regfiBase
 
Struct REGFI_VK_REC:
    unsigned int  : offset
    unsigned int  : cell_size
    REGFI_DATA : data
    char * : valuename
    uint64_t : name_length
    unsigned int  : hbin_off
    unsigned int  : data_size
    unsigned int  : data_off
    REGFI_DATA_TYPE : type
    uint64_t : flags
    uint64_t : unknown1


    # Key structure
 * @ingroup regfiBase
 
Struct REGFI_NK_REC:
    unsigned int  : offset
    unsigned int  : cell_size
    uint64_t : flags
    uint64_t : name_length
    uint64_t : classname_length
    char * : keyname
    unsigned int  : parent_off
    unsigned int  : classname_off
    unsigned int  : max_bytes_subkeyname
    unsigned int  : max_bytes_subkeyclassname
    unsigned int  : max_bytes_valuename
    unsigned int  : max_bytes_value
    unsigned int  : unknown1
    unsigned int  : unknown2
    unsigned int  : unknown3
    unsigned int  : unk_index
    unsigned int  : num_subkeys
    unsigned int  : subkeys_off
    unsigned int  : num_values
    unsigned int  : values_off
    unsigned int  : sk_off


    # Data record structure
 * @ingroup regfiBase
 
Struct REGFI_DATA:
    REGFI_DATA_TYPE : type
    unsigned int  : size
    unsigned int  : interpreted_size


    Enum REGFI_ENCODING:
    REGFI_ENCODING_DEFAULT
    REGFI_ENCODING_ASCII
    REGFI_ENCODING_UTF8
    REGFI_ENCODING_UTF16LE
    REGFI_NUM_ENCODINGS

    # This is the base class for data objects 
Class RawData(Object):
 Constructor:def RawData Con(REGFI_DATA : data , REGFI_VK_REC : record):
 Attributes:
    REGFI_DATA : data
    REGFI_VK_REC : rec

 Methods:
    def uint64_t get_value(OUT char * : buffer):

    # This is an iterator for reading values from the registry 
Class ValueIterator(Object):
 Constructor:def ValueIterator Con(KeyIterator : key):
 Attributes:

 Methods:
    Iterator returning .
    Iterator returning RawData.

    #
Class RegistryFile(Object):
 Constructor:def RegistryFile Con(char * : filename):
 Attributes:
    uint64_t : fd

 Methods:
    def KeyIterator get_key(char ** : path , REGFI_ENCODING : encoding):
    def uint64_t set_log_mask(uint64_t : mask):

    #
Class DWORDData(RawData):
 Constructor:def RawData Con(REGFI_DATA : data , REGFI_VK_REC : record):
 Attributes:
    REGFI_DATA : data
    REGFI_VK_REC : rec

 Methods:
    def uint64_t get_value():

    # This is an iterator for reading keys from the registry 
Class KeyIterator(Object):
 Constructor:def KeyIterator Con(RegistryFile : file , char ** : path , REGFI_ENCODING : encoding):
 Attributes:

 Methods:
    def ValueIterator list_values():
    Iterator returning .
    Iterator returning REGFI_NK_REC.

    #
Class DataString(RawData):
 Constructor:def RawData Con(REGFI_DATA : data , REGFI_VK_REC : record):
 Attributes:
    REGFI_DATA : data
    REGFI_VK_REC : rec

 Methods:
    def char * get_value():

    Enum REGFI_DATA_TYPE:
    REG_NONE
    REG_SZ
    REG_EXPAND_SZ
    REG_BINARY
    REG_DWORD
    REG_DWORD_LE
    REG_DWORD_BE
    REG_LINK
    REG_MULTI_SZ
    REG_RESOURCE_LIST
    REG_QWORD
    REG_KEY

    # Base object

Class Object(Obj):
 Constructor:def  Con():
 Attributes:

 Methods:

Constants:
 CHAR_BIT
 REGFI_BIG_DATA_MIN_LENGTH
 REGFI_CACHE_SK
 REGFI_CELL_MAGIC_SIZE
 REGFI_DEFAULT_LOG_MASK
 REGFI_ENCODING_ASCII
 REGFI_ENCODING_DEFAULT
 REGFI_ENCODING_UTF16LE
 REGFI_ENCODING_UTF8
 REGFI_HBIN_ALLOC
 REGFI_HBIN_HEADER_SIZE
 REGFI_HBIN_MAGIC_SIZE
 REGFI_LOG_ERROR
 REGFI_LOG_INFO
 REGFI_LOG_WARN
 REGFI_MAX_DEPTH
 REGFI_MAX_SUBKEY_DEPTH
 REGFI_MTIME_MAX_HIGH
 REGFI_MTIME_MIN_HIGH
 REGFI_NK_FLAG_ASCIINAME
 REGFI_NK_FLAG_HIVE_LINK
 REGFI_NK_FLAG_LINK
 REGFI_NK_FLAG_NO_RM
 REGFI_NK_FLAG_PREDEF_KEY
 REGFI_NK_FLAG_ROOT
 REGFI_NK_FLAG_UNKNOWN1
 REGFI_NK_FLAG_UNKNOWN2
 REGFI_NK_FLAG_UNKNOWN3
 REGFI_NK_FLAG_VOLATILE
 REGFI_NK_KNOWN_FLAGS
 REGFI_NK_MIN_LENGTH
 REGFI_NUM_ENCODINGS
 REGFI_OFFSET_NONE
 REGFI_REGF_MAGIC_SIZE
 REGFI_REGF_NAME_SIZE
 REGFI_REGF_RESERVED1_SIZE
 REGFI_REGF_RESERVED2_SIZE
 REGFI_REGF_SIZE
 REGFI_SK_MIN_LENGTH
 REGFI_SUBKEY_LIST_MIN_LEN
 REGFI_VK_DATA_IN_OFFSET
 REGFI_VK_FLAG_ASCIINAME
 REGFI_VK_MAX_DATA_LENGTH
 REGFI_VK_MIN_LENGTH
 REG_BINARY
 REG_DWORD
 REG_DWORD_BE
 REG_DWORD_LE
 REG_EXPAND_SZ
 REG_KEY
 REG_LINK
 REG_MULTI_SZ
 REG_NONE
 REG_QWORD
 REG_RESOURCE_LIST
 REG_SZ
 TIME_FIXUP_CONSTANT
 TIME_T_MAX
 TIME_T_MIN
***********************************************************************/
#include <Python.h>
#include "/usr/local/include/regfi/regfi.h"
#include "/home/mic/projects/aff4/python2.6/regfi/pyregfi.h"

/* The following is a static array mapping CLASS() pointers to their
python wrappers. This is used to allow the correct wrapper to be
chosen depending on the object type found - regardless of the
prototype.

This is basically a safer way for us to cast the correct python type
depending on context rather than assuming a type based on the .h
definition. For example consider the function

AFFObject Resolver.open(uri, mode)

The .h file implies that an AFFObject object is returned, but this is
not true as most of the time an object of a derived class will be
returned. In C we cast the returned value to the correct type. In the
python wrapper we just instantiate the correct python object wrapper
at runtime depending on the actual returned type. We use this lookup
table to do so.
*/
static int TOTAL_CLASSES=0;

/* This is a global reference to this module so classes can call each
   other.
*/
static PyObject *g_module = NULL;

static struct python_wrapper_map_t {
       Object class_ref;
       PyTypeObject *python_type;
} python_wrappers[26];

/** This is a generic wrapper type */
typedef struct {
  PyObject_HEAD
  void *base;
  void *ctx;
} Gen_wrapper;

/* Create the relevant wrapper from the item based on the lookup
table.
*/
Gen_wrapper *new_class_wrapper(Object item) {
   int i;
   Gen_wrapper *result;
   Object cls;

   // Return None for a NULL pointer
   if(!item) {
     Py_INCREF(Py_None);
     return (Gen_wrapper *)Py_None;
   };

   // Search for subclasses
   for(cls=(Object)item->__class__; cls != cls->__super__; cls=cls->__super__) {
     for(i=0; i<TOTAL_CLASSES; i++) {
       if(python_wrappers[i].class_ref == cls) {
         PyErr_Clear();

         result = (Gen_wrapper *)_PyObject_New(python_wrappers[i].python_type);
         result->ctx = talloc_asprintf(NULL, "new_class_wrapper %s@%p", NAMEOF(item), item);
         result->base = (void *)item;

         /* If its owned by the null_context it means that the function does
            not want to own the memory - we therefore steal it so it gets freed
            with the python object. */
         if(talloc_parent(result->base) == null_context)
                  talloc_steal(result->ctx, result->base);

         return result;
       };
     };
   };

  PyErr_Format(PyExc_RuntimeError, "Unable to find a wrapper for object %s", NAMEOF(item));
  return NULL;
};

static PyObject *resolve_exception(char **error_buff) {
  enum _error_type *type = aff4_get_current_error(error_buff);
  switch(*type) {
case EProgrammingError:
    return PyExc_SystemError;
case EKeyError:
    return PyExc_KeyError;
case ERuntimeError:
    return PyExc_RuntimeError;
case EWarning:
    return PyExc_AssertionError;
default:
    return PyExc_RuntimeError;
};
};

static int type_check(PyObject *obj, PyTypeObject *type) {
   PyTypeObject *tmp;

   // Recurse through the inheritance tree and check if the types are expected
   if(obj)
     for(tmp = obj->ob_type; tmp && tmp != &PyBaseObject_Type; tmp = tmp->tp_base) {
       if(tmp == type) return 1;
     };

  return 0;
};

static int check_error() {
   if(!CheckError(EZero)) {
         char *buffer;
         PyObject *exception = resolve_exception(&buffer);

         PyErr_Format(exception, "%s", buffer);
         ClearError();
         return 1;
   };
  return 0;
};

#define CHECK_ERROR if(check_error()) goto error;

/******************** REGFI_DATA ***********************/
typedef struct {
  PyObject_HEAD
  REGFI_DATA *base;
  void *ctx;
} pyREGFI_DATA;

staticforward PyTypeObject REGFI_DATA_Type;

static int pyREGFI_DATA_init(pyREGFI_DATA *self, PyObject *args, PyObject *kwds)
;

static PyObject *pyREGFI_DATA_getattr(pyREGFI_DATA *self, PyObject *name);
/******************** REGFI_NK_REC ***********************/
typedef struct {
  PyObject_HEAD
  REGFI_NK_REC *base;
  void *ctx;
} pyREGFI_NK_REC;

staticforward PyTypeObject REGFI_NK_REC_Type;

static int pyREGFI_NK_REC_init(pyREGFI_NK_REC *self, PyObject *args, PyObject *kwds)
;

static PyObject *pyREGFI_NK_REC_getattr(pyREGFI_NK_REC *self, PyObject *name);
/******************** KeyIterator ***********************/
typedef struct {
  PyObject_HEAD
  KeyIterator base;
  void *ctx;
} pyKeyIterator;

staticforward PyTypeObject KeyIterator_Type;

static int pyKeyIterator_init(pyKeyIterator *self, PyObject *args, PyObject *kwds)
;

static PyObject *pyKeyIterator_getattr(pyKeyIterator *self, PyObject *name);
static PyObject *pyKeyIterator_list_values(pyKeyIterator *self, PyObject *args, PyObject *kwds) ;
static PyObject *pyKeyIterator___iter__(pyKeyIterator *self);
static PyObject *pyKeyIterator_iternext(pyKeyIterator *self);
/******************** Object ***********************/
typedef struct {
  PyObject_HEAD
  Object base;
  void *ctx;
} pyObject;

staticforward PyTypeObject Object_Type;

static int pyObject_init(pyObject *self, PyObject *args, PyObject *kwds)
;

static PyObject *pyObject_getattr(pyObject *self, PyObject *name);
/******************** RegistryFile ***********************/
typedef struct {
  PyObject_HEAD
  RegistryFile base;
  void *ctx;
} pyRegistryFile;

staticforward PyTypeObject RegistryFile_Type;

static int pyRegistryFile_init(pyRegistryFile *self, PyObject *args, PyObject *kwds)
;

static PyObject *pyRegistryFile_getattr(pyRegistryFile *self, PyObject *name);
static PyObject *pyRegistryFile_get_key(pyRegistryFile *self, PyObject *args, PyObject *kwds) ;
static PyObject *pyRegistryFile_set_log_mask(pyRegistryFile *self, PyObject *args, PyObject *kwds) ;
/******************** DataString ***********************/
typedef struct {
  PyObject_HEAD
  DataString base;
  void *ctx;
} pyDataString;

staticforward PyTypeObject DataString_Type;

static int pyDataString_init(pyDataString *self, PyObject *args, PyObject *kwds)
;

static PyObject *pyDataString_getattr(pyDataString *self, PyObject *name);
static PyObject *pyDataString_get_value(pyDataString *self, PyObject *args, PyObject *kwds) ;
/******************** RawData ***********************/
typedef struct {
  PyObject_HEAD
  RawData base;
  void *ctx;
} pyRawData;

staticforward PyTypeObject RawData_Type;

static int pyRawData_init(pyRawData *self, PyObject *args, PyObject *kwds)
;

static PyObject *pyRawData_getattr(pyRawData *self, PyObject *name);
static PyObject *pyRawData_get_value(pyRawData *self, PyObject *args, PyObject *kwds) ;
/******************** REGFI_ENCODING ***********************/
typedef struct {
  PyObject_HEAD
  PyObject *value;
} pyREGFI_ENCODING;



static PyObject *REGFI_ENCODING_Dict_lookup;
static PyObject *REGFI_ENCODING_rev_lookup;
staticforward PyTypeObject REGFI_ENCODING_Type;

static int pyREGFI_ENCODING_init(pyREGFI_ENCODING *self, PyObject *args, PyObject *kwds)
;
/******************** REGFI_DATA_TYPE ***********************/
typedef struct {
  PyObject_HEAD
  PyObject *value;
} pyREGFI_DATA_TYPE;



static PyObject *REGFI_DATA_TYPE_Dict_lookup;
static PyObject *REGFI_DATA_TYPE_rev_lookup;
staticforward PyTypeObject REGFI_DATA_TYPE_Type;

static int pyREGFI_DATA_TYPE_init(pyREGFI_DATA_TYPE *self, PyObject *args, PyObject *kwds)
;
/******************** ValueIterator ***********************/
typedef struct {
  PyObject_HEAD
  ValueIterator base;
  void *ctx;
} pyValueIterator;

staticforward PyTypeObject ValueIterator_Type;

static int pyValueIterator_init(pyValueIterator *self, PyObject *args, PyObject *kwds)
;

static PyObject *pyValueIterator_getattr(pyValueIterator *self, PyObject *name);
static PyObject *pyValueIterator___iter__(pyValueIterator *self);
static PyObject *pyValueIterator_iternext(pyValueIterator *self);
/******************** REGFI_VK_REC ***********************/
typedef struct {
  PyObject_HEAD
  REGFI_VK_REC *base;
  void *ctx;
} pyREGFI_VK_REC;

staticforward PyTypeObject REGFI_VK_REC_Type;

static int pyREGFI_VK_REC_init(pyREGFI_VK_REC *self, PyObject *args, PyObject *kwds)
;

static PyObject *pyREGFI_VK_REC_getattr(pyREGFI_VK_REC *self, PyObject *name);
/******************** DWORDData ***********************/
typedef struct {
  PyObject_HEAD
  DWORDData base;
  void *ctx;
} pyDWORDData;

staticforward PyTypeObject DWORDData_Type;

static int pyDWORDData_init(pyDWORDData *self, PyObject *args, PyObject *kwds)
;

static PyObject *pyDWORDData_getattr(pyDWORDData *self, PyObject *name);
static PyObject *pyDWORDData_get_value(pyDWORDData *self, PyObject *args, PyObject *kwds) ;
/*****************************************************
             Implementation
******************************************************/

static PyMethodDef REGFI_DATA_methods[] = {
     {NULL}  /* Sentinel */
};
static void
REGFI_DATA_dealloc(pyREGFI_DATA *self) {
   talloc_free(self->ctx);
};

static int pyREGFI_DATA_init(pyREGFI_DATA *self, PyObject *args, PyObject *kwds) {

self->ctx = talloc_strdup(NULL, "REGFI_DATA");
self->base = talloc(self->ctx, REGFI_DATA);
  return 0;
};


static PyObject *pyREGFI_DATA_getattr(pyREGFI_DATA *self, PyObject *pyname) {
  char *name;
  // Try to hand it off to the python native handler first
  PyObject *result = PyObject_GenericGetAttr((PyObject*)self, pyname);

  if(result) return result;

  PyErr_Clear();
  // No - nothing interesting was found by python
  name = PyString_AsString(pyname);

  if(!self->base) return PyErr_Format(PyExc_RuntimeError, "Wrapped object (REGFI_DATA.pyREGFI_DATA_getattr) no longer valid");
  if(!name) return NULL;
  if(!strcmp(name, "__members__")) {
     PyObject *result = PyList_New(0);
     PyObject *tmp;
     PyMethodDef *i;

     if(!result) goto error;
 tmp = PyString_FromString("type");
    PyList_Append(result, tmp); Py_DECREF(tmp);
 tmp = PyString_FromString("size");
    PyList_Append(result, tmp); Py_DECREF(tmp);
 tmp = PyString_FromString("interpreted_size");
    PyList_Append(result, tmp); Py_DECREF(tmp);


    for(i=REGFI_DATA_methods; i->ml_name; i++) {
     tmp = PyString_FromString(i->ml_name);
    PyList_Append(result, tmp); Py_DECREF(tmp);
    }; 
     return result; 
   }

if(!strcmp(name, "type")) {
    PyObject *py_result;
    REGFI_DATA_TYPE __attribute__((unused)) type;


    Py_BEGIN_ALLOW_THREADS
type = (self->base->type);
Py_END_ALLOW_THREADS

    PyErr_Clear();
py_result = PyObject_CallMethod(g_module, "REGFI_DATA_TYPE", "K", (uint64_t)type);

    return py_result;
};
if(!strcmp(name, "size")) {
    PyObject *py_result;
    unsigned int  __attribute__((unused)) size;


    Py_BEGIN_ALLOW_THREADS
size = (self->base->size);
Py_END_ALLOW_THREADS

    PyErr_Clear();
py_result = PyLong_FromLong(size);

    return py_result;
};
if(!strcmp(name, "interpreted_size")) {
    PyObject *py_result;
    unsigned int  __attribute__((unused)) interpreted_size;


    Py_BEGIN_ALLOW_THREADS
interpreted_size = (self->base->interpreted_size);
Py_END_ALLOW_THREADS

    PyErr_Clear();
py_result = PyLong_FromLong(interpreted_size);

    return py_result;
};

  return PyObject_GenericGetAttr((PyObject *)self, pyname);
error:
return NULL;
}


static int
REGFI_DATA_nonzero(pyREGFI_DATA *v)
{
        return v->base != 0;
};

static PyNumberMethods REGFI_DATA_as_number = {
        (binaryfunc)    0,       /*nb_add*/
        (binaryfunc)    0,       /*nb_subtract*/
        (binaryfunc)    0,       /*nb_multiply*/
                        0,       /*nb_divide*/
                        0,       /*nb_remainder*/
                        0,       /*nb_divmod*/
                        0,       /*nb_power*/
        (unaryfunc)     0,       /*nb_negative*/
        (unaryfunc)     0,       /*tp_positive*/
        (unaryfunc)     0,       /*tp_absolute*/
        (inquiry)       REGFI_DATA_nonzero,   /*tp_nonzero*/
        (unaryfunc)     0,       /*nb_invert*/
                        0,       /*nb_lshift*/
        (binaryfunc)    0,       /*nb_rshift*/
                        0,       /*nb_and*/
                        0,       /*nb_xor*/
                        0,       /*nb_or*/
                        0,       /*nb_coerce*/
         (unaryfunc)    0,       /*nb_int*/
                        0,       /*nb_long*/
                        0,       /*nb_float*/
                        0,       /*nb_oct*/
                        0,       /*nb_hex*/
        0,                              /* nb_inplace_add */
        0,                              /* nb_inplace_subtract */
        0,                              /* nb_inplace_multiply */
        0,                              /* nb_inplace_divide */
        0,                              /* nb_inplace_remainder */
        0,                              /* nb_inplace_power */
        0,                              /* nb_inplace_lshift */
        0,                              /* nb_inplace_rshift */
        0,                              /* nb_inplace_and */
        0,                              /* nb_inplace_xor */
        0,                              /* nb_inplace_or */
        0,                              /* nb_floor_divide */
        0,                              /* nb_true_divide */
        0,                              /* nb_inplace_floor_divide */
        0,                              /* nb_inplace_true_divide */
        0,                              /* nb_index */
};

static PyTypeObject REGFI_DATA_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                         /* ob_size */
    "pyregfi.REGFI_DATA",               /* tp_name */
    sizeof(pyREGFI_DATA),            /* tp_basicsize */
    0,                         /* tp_itemsize */
    (destructor)REGFI_DATA_dealloc,/* tp_dealloc */
    0,                         /* tp_print */
    0,                         /* tp_getattr */
    0,                         /* tp_setattr */
    0,                         /* tp_compare */
    0,                         /* tp_repr */
    &REGFI_DATA_as_number,      /* tp_as_number */
    0,                         /* tp_as_sequence */
    0,                         /* tp_as_mapping */
    0,                         /* tp_hash */
    0,                         /* tp_call */
    (reprfunc)0,      /* tp_str */
    (getattrofunc)pyREGFI_DATA_getattr,                         /* tp_getattro */
    0,                         /* tp_setattro */
    0,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,        /* tp_flags */
    "REGFI_DATA:  Data record structure\n * @ingroup regfiBase\n ",     /* tp_doc */
    0,	                       /* tp_traverse */
    0,                         /* tp_clear */
    0,                         /* tp_richcompare */
    0,                         /* tp_weaklistoffset */
    (getiterfunc)0,              /* tp_iter */
    (iternextfunc)0,/* tp_iternext */
    REGFI_DATA_methods,         /* tp_methods */
    0,                         /* tp_members */
    0,                         /* tp_getset */
    0,                         /* tp_base */
    0,                         /* tp_dict */
    0,                         /* tp_descr_get */
    0,                         /* tp_descr_set */
    0,                         /* tp_dictoffset */
    (initproc)pyREGFI_DATA_init,      /* tp_init */
    0,                         /* tp_alloc */
    0,                         /* tp_new */
};
static PyMethodDef REGFI_NK_REC_methods[] = {
     {NULL}  /* Sentinel */
};
static void
REGFI_NK_REC_dealloc(pyREGFI_NK_REC *self) {
   talloc_free(self->ctx);
};

static int pyREGFI_NK_REC_init(pyREGFI_NK_REC *self, PyObject *args, PyObject *kwds) {

self->ctx = talloc_strdup(NULL, "REGFI_NK_REC");
self->base = talloc(self->ctx, REGFI_NK_REC);
  return 0;
};


static PyObject *pyREGFI_NK_REC_getattr(pyREGFI_NK_REC *self, PyObject *pyname) {
  char *name;
  // Try to hand it off to the python native handler first
  PyObject *result = PyObject_GenericGetAttr((PyObject*)self, pyname);

  if(result) return result;

  PyErr_Clear();
  // No - nothing interesting was found by python
  name = PyString_AsString(pyname);

  if(!self->base) return PyErr_Format(PyExc_RuntimeError, "Wrapped object (REGFI_NK_REC.pyREGFI_NK_REC_getattr) no longer valid");
  if(!name) return NULL;
  if(!strcmp(name, "__members__")) {
     PyObject *result = PyList_New(0);
     PyObject *tmp;
     PyMethodDef *i;

     if(!result) goto error;
 tmp = PyString_FromString("offset");
    PyList_Append(result, tmp); Py_DECREF(tmp);
 tmp = PyString_FromString("cell_size");
    PyList_Append(result, tmp); Py_DECREF(tmp);
 tmp = PyString_FromString("flags");
    PyList_Append(result, tmp); Py_DECREF(tmp);
 tmp = PyString_FromString("name_length");
    PyList_Append(result, tmp); Py_DECREF(tmp);
 tmp = PyString_FromString("classname_length");
    PyList_Append(result, tmp); Py_DECREF(tmp);
 tmp = PyString_FromString("keyname");
    PyList_Append(result, tmp); Py_DECREF(tmp);
 tmp = PyString_FromString("parent_off");
    PyList_Append(result, tmp); Py_DECREF(tmp);
 tmp = PyString_FromString("classname_off");
    PyList_Append(result, tmp); Py_DECREF(tmp);
 tmp = PyString_FromString("max_bytes_subkeyname");
    PyList_Append(result, tmp); Py_DECREF(tmp);
 tmp = PyString_FromString("max_bytes_subkeyclassname");
    PyList_Append(result, tmp); Py_DECREF(tmp);
 tmp = PyString_FromString("max_bytes_valuename");
    PyList_Append(result, tmp); Py_DECREF(tmp);
 tmp = PyString_FromString("max_bytes_value");
    PyList_Append(result, tmp); Py_DECREF(tmp);
 tmp = PyString_FromString("unknown1");
    PyList_Append(result, tmp); Py_DECREF(tmp);
 tmp = PyString_FromString("unknown2");
    PyList_Append(result, tmp); Py_DECREF(tmp);
 tmp = PyString_FromString("unknown3");
    PyList_Append(result, tmp); Py_DECREF(tmp);
 tmp = PyString_FromString("unk_index");
    PyList_Append(result, tmp); Py_DECREF(tmp);
 tmp = PyString_FromString("num_subkeys");
    PyList_Append(result, tmp); Py_DECREF(tmp);
 tmp = PyString_FromString("subkeys_off");
    PyList_Append(result, tmp); Py_DECREF(tmp);
 tmp = PyString_FromString("num_values");
    PyList_Append(result, tmp); Py_DECREF(tmp);
 tmp = PyString_FromString("values_off");
    PyList_Append(result, tmp); Py_DECREF(tmp);
 tmp = PyString_FromString("sk_off");
    PyList_Append(result, tmp); Py_DECREF(tmp);


    for(i=REGFI_NK_REC_methods; i->ml_name; i++) {
     tmp = PyString_FromString(i->ml_name);
    PyList_Append(result, tmp); Py_DECREF(tmp);
    }; 
     return result; 
   }

if(!strcmp(name, "offset")) {
    PyObject *py_result;
    unsigned int  __attribute__((unused)) offset;


    Py_BEGIN_ALLOW_THREADS
offset = (self->base->offset);
Py_END_ALLOW_THREADS

    PyErr_Clear();
py_result = PyLong_FromLong(offset);

    return py_result;
};
if(!strcmp(name, "cell_size")) {
    PyObject *py_result;
    unsigned int  __attribute__((unused)) cell_size;


    Py_BEGIN_ALLOW_THREADS
cell_size = (self->base->cell_size);
Py_END_ALLOW_THREADS

    PyErr_Clear();
py_result = PyLong_FromLong(cell_size);

    return py_result;
};
if(!strcmp(name, "flags")) {
    PyObject *py_result;
    uint64_t __attribute__((unused)) flags;


    Py_BEGIN_ALLOW_THREADS
flags = (self->base->flags);
Py_END_ALLOW_THREADS

    PyErr_Clear();
py_result = PyLong_FromLongLong(flags);

    return py_result;
};
if(!strcmp(name, "name_length")) {
    PyObject *py_result;
    uint64_t __attribute__((unused)) name_length;


    Py_BEGIN_ALLOW_THREADS
name_length = (self->base->name_length);
Py_END_ALLOW_THREADS

    PyErr_Clear();
py_result = PyLong_FromLongLong(name_length);

    return py_result;
};
if(!strcmp(name, "classname_length")) {
    PyObject *py_result;
    uint64_t __attribute__((unused)) classname_length;


    Py_BEGIN_ALLOW_THREADS
classname_length = (self->base->classname_length);
Py_END_ALLOW_THREADS

    PyErr_Clear();
py_result = PyLong_FromLongLong(classname_length);

    return py_result;
};
if(!strcmp(name, "keyname")) {
    PyObject *py_result;
    char * __attribute__((unused)) keyname;


    Py_BEGIN_ALLOW_THREADS
keyname = (self->base->keyname);
Py_END_ALLOW_THREADS

    PyErr_Clear();
   if(!keyname) { PyErr_Format(PyExc_RuntimeError, "keyname is NULL"); goto error; };
   py_result = PyString_FromStringAndSize((char *)keyname, strlen(keyname));
if(!py_result) goto error;

    return py_result;
};
if(!strcmp(name, "parent_off")) {
    PyObject *py_result;
    unsigned int  __attribute__((unused)) parent_off;


    Py_BEGIN_ALLOW_THREADS
parent_off = (self->base->parent_off);
Py_END_ALLOW_THREADS

    PyErr_Clear();
py_result = PyLong_FromLong(parent_off);

    return py_result;
};
if(!strcmp(name, "classname_off")) {
    PyObject *py_result;
    unsigned int  __attribute__((unused)) classname_off;


    Py_BEGIN_ALLOW_THREADS
classname_off = (self->base->classname_off);
Py_END_ALLOW_THREADS

    PyErr_Clear();
py_result = PyLong_FromLong(classname_off);

    return py_result;
};
if(!strcmp(name, "max_bytes_subkeyname")) {
    PyObject *py_result;
    unsigned int  __attribute__((unused)) max_bytes_subkeyname;


    Py_BEGIN_ALLOW_THREADS
max_bytes_subkeyname = (self->base->max_bytes_subkeyname);
Py_END_ALLOW_THREADS

    PyErr_Clear();
py_result = PyLong_FromLong(max_bytes_subkeyname);

    return py_result;
};
if(!strcmp(name, "max_bytes_subkeyclassname")) {
    PyObject *py_result;
    unsigned int  __attribute__((unused)) max_bytes_subkeyclassname;


    Py_BEGIN_ALLOW_THREADS
max_bytes_subkeyclassname = (self->base->max_bytes_subkeyclassname);
Py_END_ALLOW_THREADS

    PyErr_Clear();
py_result = PyLong_FromLong(max_bytes_subkeyclassname);

    return py_result;
};
if(!strcmp(name, "max_bytes_valuename")) {
    PyObject *py_result;
    unsigned int  __attribute__((unused)) max_bytes_valuename;


    Py_BEGIN_ALLOW_THREADS
max_bytes_valuename = (self->base->max_bytes_valuename);
Py_END_ALLOW_THREADS

    PyErr_Clear();
py_result = PyLong_FromLong(max_bytes_valuename);

    return py_result;
};
if(!strcmp(name, "max_bytes_value")) {
    PyObject *py_result;
    unsigned int  __attribute__((unused)) max_bytes_value;


    Py_BEGIN_ALLOW_THREADS
max_bytes_value = (self->base->max_bytes_value);
Py_END_ALLOW_THREADS

    PyErr_Clear();
py_result = PyLong_FromLong(max_bytes_value);

    return py_result;
};
if(!strcmp(name, "unknown1")) {
    PyObject *py_result;
    unsigned int  __attribute__((unused)) unknown1;


    Py_BEGIN_ALLOW_THREADS
unknown1 = (self->base->unknown1);
Py_END_ALLOW_THREADS

    PyErr_Clear();
py_result = PyLong_FromLong(unknown1);

    return py_result;
};
if(!strcmp(name, "unknown2")) {
    PyObject *py_result;
    unsigned int  __attribute__((unused)) unknown2;


    Py_BEGIN_ALLOW_THREADS
unknown2 = (self->base->unknown2);
Py_END_ALLOW_THREADS

    PyErr_Clear();
py_result = PyLong_FromLong(unknown2);

    return py_result;
};
if(!strcmp(name, "unknown3")) {
    PyObject *py_result;
    unsigned int  __attribute__((unused)) unknown3;


    Py_BEGIN_ALLOW_THREADS
unknown3 = (self->base->unknown3);
Py_END_ALLOW_THREADS

    PyErr_Clear();
py_result = PyLong_FromLong(unknown3);

    return py_result;
};
if(!strcmp(name, "unk_index")) {
    PyObject *py_result;
    unsigned int  __attribute__((unused)) unk_index;


    Py_BEGIN_ALLOW_THREADS
unk_index = (self->base->unk_index);
Py_END_ALLOW_THREADS

    PyErr_Clear();
py_result = PyLong_FromLong(unk_index);

    return py_result;
};
if(!strcmp(name, "num_subkeys")) {
    PyObject *py_result;
    unsigned int  __attribute__((unused)) num_subkeys;


    Py_BEGIN_ALLOW_THREADS
num_subkeys = (self->base->num_subkeys);
Py_END_ALLOW_THREADS

    PyErr_Clear();
py_result = PyLong_FromLong(num_subkeys);

    return py_result;
};
if(!strcmp(name, "subkeys_off")) {
    PyObject *py_result;
    unsigned int  __attribute__((unused)) subkeys_off;


    Py_BEGIN_ALLOW_THREADS
subkeys_off = (self->base->subkeys_off);
Py_END_ALLOW_THREADS

    PyErr_Clear();
py_result = PyLong_FromLong(subkeys_off);

    return py_result;
};
if(!strcmp(name, "num_values")) {
    PyObject *py_result;
    unsigned int  __attribute__((unused)) num_values;


    Py_BEGIN_ALLOW_THREADS
num_values = (self->base->num_values);
Py_END_ALLOW_THREADS

    PyErr_Clear();
py_result = PyLong_FromLong(num_values);

    return py_result;
};
if(!strcmp(name, "values_off")) {
    PyObject *py_result;
    unsigned int  __attribute__((unused)) values_off;


    Py_BEGIN_ALLOW_THREADS
values_off = (self->base->values_off);
Py_END_ALLOW_THREADS

    PyErr_Clear();
py_result = PyLong_FromLong(values_off);

    return py_result;
};
if(!strcmp(name, "sk_off")) {
    PyObject *py_result;
    unsigned int  __attribute__((unused)) sk_off;


    Py_BEGIN_ALLOW_THREADS
sk_off = (self->base->sk_off);
Py_END_ALLOW_THREADS

    PyErr_Clear();
py_result = PyLong_FromLong(sk_off);

    return py_result;
};

  return PyObject_GenericGetAttr((PyObject *)self, pyname);
error:
return NULL;
}


static int
REGFI_NK_REC_nonzero(pyREGFI_NK_REC *v)
{
        return v->base != 0;
};

static PyNumberMethods REGFI_NK_REC_as_number = {
        (binaryfunc)    0,       /*nb_add*/
        (binaryfunc)    0,       /*nb_subtract*/
        (binaryfunc)    0,       /*nb_multiply*/
                        0,       /*nb_divide*/
                        0,       /*nb_remainder*/
                        0,       /*nb_divmod*/
                        0,       /*nb_power*/
        (unaryfunc)     0,       /*nb_negative*/
        (unaryfunc)     0,       /*tp_positive*/
        (unaryfunc)     0,       /*tp_absolute*/
        (inquiry)       REGFI_NK_REC_nonzero,   /*tp_nonzero*/
        (unaryfunc)     0,       /*nb_invert*/
                        0,       /*nb_lshift*/
        (binaryfunc)    0,       /*nb_rshift*/
                        0,       /*nb_and*/
                        0,       /*nb_xor*/
                        0,       /*nb_or*/
                        0,       /*nb_coerce*/
         (unaryfunc)    0,       /*nb_int*/
                        0,       /*nb_long*/
                        0,       /*nb_float*/
                        0,       /*nb_oct*/
                        0,       /*nb_hex*/
        0,                              /* nb_inplace_add */
        0,                              /* nb_inplace_subtract */
        0,                              /* nb_inplace_multiply */
        0,                              /* nb_inplace_divide */
        0,                              /* nb_inplace_remainder */
        0,                              /* nb_inplace_power */
        0,                              /* nb_inplace_lshift */
        0,                              /* nb_inplace_rshift */
        0,                              /* nb_inplace_and */
        0,                              /* nb_inplace_xor */
        0,                              /* nb_inplace_or */
        0,                              /* nb_floor_divide */
        0,                              /* nb_true_divide */
        0,                              /* nb_inplace_floor_divide */
        0,                              /* nb_inplace_true_divide */
        0,                              /* nb_index */
};

static PyTypeObject REGFI_NK_REC_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                         /* ob_size */
    "pyregfi.REGFI_NK_REC",               /* tp_name */
    sizeof(pyREGFI_NK_REC),            /* tp_basicsize */
    0,                         /* tp_itemsize */
    (destructor)REGFI_NK_REC_dealloc,/* tp_dealloc */
    0,                         /* tp_print */
    0,                         /* tp_getattr */
    0,                         /* tp_setattr */
    0,                         /* tp_compare */
    0,                         /* tp_repr */
    &REGFI_NK_REC_as_number,      /* tp_as_number */
    0,                         /* tp_as_sequence */
    0,                         /* tp_as_mapping */
    0,                         /* tp_hash */
    0,                         /* tp_call */
    (reprfunc)0,      /* tp_str */
    (getattrofunc)pyREGFI_NK_REC_getattr,                         /* tp_getattro */
    0,                         /* tp_setattro */
    0,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,        /* tp_flags */
    "REGFI_NK_REC:  Key structure\n * @ingroup regfiBase\n ",     /* tp_doc */
    0,	                       /* tp_traverse */
    0,                         /* tp_clear */
    0,                         /* tp_richcompare */
    0,                         /* tp_weaklistoffset */
    (getiterfunc)0,              /* tp_iter */
    (iternextfunc)0,/* tp_iternext */
    REGFI_NK_REC_methods,         /* tp_methods */
    0,                         /* tp_members */
    0,                         /* tp_getset */
    0,                         /* tp_base */
    0,                         /* tp_dict */
    0,                         /* tp_descr_get */
    0,                         /* tp_descr_set */
    0,                         /* tp_dictoffset */
    (initproc)pyREGFI_NK_REC_init,      /* tp_init */
    0,                         /* tp_alloc */
    0,                         /* tp_new */
};
static PyMethodDef KeyIterator_methods[] = {
     {"list_values",(PyCFunction)pyKeyIterator_list_values, METH_VARARGS|METH_KEYWORDS, "struct ValueIterator_t * KeyIterator.list_values();\n\n\n"},
     {NULL}  /* Sentinel */
};
static void
KeyIterator_dealloc(pyKeyIterator *self) {

    if(self->base) {
        //printf("Unlinking %s@%p\n", NAMEOF(self->base), self->base);
        talloc_free(self->ctx);
        self->base=NULL;
    };

 PyObject_Del(self);
};


static int pyKeyIterator_init(pyKeyIterator *self, PyObject *args, PyObject *kwds)
{
Gen_wrapper *file __attribute__((unused)) = NULL;
 RegistryFile __attribute__((unused)) call_file;
char **path=NULL; PyObject *py_path=NULL;
REGFI_ENCODING __attribute__((unused)) encoding;
static char *kwlist[] = {"file","path","encoding", NULL};

if(!PyArg_ParseTupleAndKeywords(args, kwds, "OOi|", kwlist, &file,&py_path,&encoding))
 goto error;


if(!file || (PyObject *)file==Py_None) {
   call_file = NULL;
} else if(!type_check((PyObject *)file,&RegistryFile_Type)) {
     PyErr_Format(PyExc_RuntimeError, "file must be derived from type RegistryFile");
     goto error;
} else {
   call_file = file->base;
};
{
Py_ssize_t i,size=0;

if(py_path) {
   if(!PySequence_Check(py_path)) {
     PyErr_Format(PyExc_ValueError, "path must be a sequence");
     goto error;
   };

   size = PySequence_Size(py_path);
};

path = talloc_zero_array(NULL, char *, size + 1);

for(i=0; i<size;i++) {
 PyObject *tmp = PySequence_GetItem(py_path, i);
 if(!tmp) goto error;
 path[i] = PyString_AsString(tmp);
 if(!path[i]) {
   Py_DECREF(tmp);
   goto error;
 };
 Py_DECREF(tmp);
};

};
// Check if the integer passed is actually a valid member of the enum
// Enum value of 0 is always allowed
if(encoding) { PyObject *py_encoding = PyLong_FromLong(encoding);
  PyObject *tmp = PyDict_GetItem(REGFI_ENCODING_rev_lookup, py_encoding);

  Py_DECREF(py_encoding);
  if(!tmp) {
    PyErr_Format(PyExc_RuntimeError, "value %lu is not valid for Enum REGFI_ENCODING of arg 'encoding'", (unsigned long)encoding);
    goto error;
  };
  Py_DECREF(tmp);
};

self->ctx = talloc_strdup(NULL, "KeyIterator");
 ClearError();
Py_BEGIN_ALLOW_THREADS
self->base = CONSTRUCT(KeyIterator, KeyIterator, Con, self->ctx, call_file, path, encoding);
Py_END_ALLOW_THREADS

       if(!CheckError(EZero)) {
         char *buffer;
         PyObject *exception = resolve_exception(&buffer);

         PyErr_Format(exception,
                    "%s", buffer);
         ClearError();
         goto error;
  } else if(!self->base) {
    PyErr_Format(PyExc_IOError, "Unable to construct class KeyIterator");
    goto error;
  };
  return 0;
error:
    return -1;
};


static PyObject *pyKeyIterator_getattr(pyKeyIterator *self, PyObject *pyname) {
  char *name;
  // Try to hand it off to the python native handler first
  PyObject *result = PyObject_GenericGetAttr((PyObject*)self, pyname);

  if(result) return result;

  PyErr_Clear();
  // No - nothing interesting was found by python
  name = PyString_AsString(pyname);

  if(!self->base) return PyErr_Format(PyExc_RuntimeError, "Wrapped object (KeyIterator.pyKeyIterator_getattr) no longer valid");
  if(!name) return NULL;
  if(!strcmp(name, "__members__")) {
     PyObject *result = PyList_New(0);
     PyObject *tmp;
     PyMethodDef *i;

     if(!result) goto error;


    for(i=KeyIterator_methods; i->ml_name; i++) {
     tmp = PyString_FromString(i->ml_name);
    PyList_Append(result, tmp); Py_DECREF(tmp);
    }; 
     return result; 
   }


  return PyObject_GenericGetAttr((PyObject *)self, pyname);
error:
return NULL;
}


/********************************************************
Autogenerated wrapper for function:
struct ValueIterator_t * KeyIterator.list_values();
********************************************************/
static PyObject *pyKeyIterator_list_values(pyKeyIterator *self, PyObject *args, PyObject *kwds) {
       PyObject *returned_result, *py_result;
Gen_wrapper *func_return __attribute__((unused)) = NULL;
// Make sure that we have something valid to wrap
if(!self->base) return PyErr_Format(PyExc_RuntimeError, "KeyIterator object no longer valid");
// Precall preparations
// Check the function is implemented
  {  void *method = ((KeyIterator)self->base)->list_values;
     if(!method || (void *)unimplemented == (void *)method) {
         PyErr_Format(PyExc_RuntimeError, "KeyIterator.list_values is not implemented");
         goto error;
     };
  };

// Make the call
 ClearError();{
       Object returned_object;

       ClearError();

       Py_BEGIN_ALLOW_THREADS
       returned_object = (Object)((KeyIterator)self->base)->list_values(((KeyIterator)self->base));
       Py_END_ALLOW_THREADS

       CHECK_ERROR;

       // A NULL return without errors means we return None
       if(!returned_object) {
         func_return = (Gen_wrapper *)Py_None;
         Py_INCREF(Py_None);

       } else {
         //printf("%s: Wrapping %s@%p\n", __FUNCTION__, NAMEOF(returned_object), returned_object);
         func_return = new_class_wrapper(returned_object);
         if(!func_return) goto error;
       };
    }

// Postcall preparations

// prepare results
py_result = (PyObject *)func_return;
returned_result = py_result;
return returned_result;

// error conditions:
error:
    return NULL;

};


/********************************************************
Autogenerated wrapper for function:
void KeyIterator.__iter__();
********************************************************/
static PyObject *pyKeyIterator___iter__(pyKeyIterator *self){
          ((KeyIterator)self->base)->__iter__((KeyIterator)self->base);
          return PyObject_SelfIter((PyObject *)self);
};

/********************************************************
Autogenerated wrapper for function:
REGFI_NK_REC * KeyIterator.iternext();
********************************************************/
static PyObject *pyKeyIterator_iternext(pyKeyIterator *self){
       PyObject *returned_result, *py_result;
Gen_wrapper *func_return = NULL;// Make sure that we have something valid to wrap
if(!self->base) return PyErr_Format(PyExc_RuntimeError, "KeyIterator object no longer valid");
// Precall preparations
// Check the function is implemented
  {  void *method = ((KeyIterator)self->base)->iternext;
     if(!method || (void *)unimplemented == (void *)method) {
         PyErr_Format(PyExc_RuntimeError, "KeyIterator.iternext is not implemented");
         goto error;
     };
  };

// Make the call
 ClearError();
PyErr_Clear();
func_return = (Gen_wrapper *)PyObject_New(pyREGFI_NK_REC, &REGFI_NK_REC_Type);
func_return->ctx = talloc_size(NULL, 1);
func_return->base = ((KeyIterator)self->base)->iternext(((KeyIterator)self->base));
if(!func_return->base) { Py_DECREF(func_return); return NULL; };
// A NULL object gets translated to a None
 if(!func_return->base) {
   Py_DECREF(func_return);
   Py_INCREF(Py_None);
   func_return = (Gen_wrapper *)Py_None;
 } else {
talloc_steal(func_return->ctx, func_return->base);
}

// Postcall preparations

// prepare results
py_result = (PyObject *)func_return;
returned_result = py_result;
return returned_result;

// error conditions:
error:
    return NULL;

};


static int
KeyIterator_nonzero(pyKeyIterator *v)
{
        return v->base != 0;
};

static PyNumberMethods KeyIterator_as_number = {
        (binaryfunc)    0,       /*nb_add*/
        (binaryfunc)    0,       /*nb_subtract*/
        (binaryfunc)    0,       /*nb_multiply*/
                        0,       /*nb_divide*/
                        0,       /*nb_remainder*/
                        0,       /*nb_divmod*/
                        0,       /*nb_power*/
        (unaryfunc)     0,       /*nb_negative*/
        (unaryfunc)     0,       /*tp_positive*/
        (unaryfunc)     0,       /*tp_absolute*/
        (inquiry)       KeyIterator_nonzero,   /*tp_nonzero*/
        (unaryfunc)     0,       /*nb_invert*/
                        0,       /*nb_lshift*/
        (binaryfunc)    0,       /*nb_rshift*/
                        0,       /*nb_and*/
                        0,       /*nb_xor*/
                        0,       /*nb_or*/
                        0,       /*nb_coerce*/
         (unaryfunc)    0,       /*nb_int*/
                        0,       /*nb_long*/
                        0,       /*nb_float*/
                        0,       /*nb_oct*/
                        0,       /*nb_hex*/
        0,                              /* nb_inplace_add */
        0,                              /* nb_inplace_subtract */
        0,                              /* nb_inplace_multiply */
        0,                              /* nb_inplace_divide */
        0,                              /* nb_inplace_remainder */
        0,                              /* nb_inplace_power */
        0,                              /* nb_inplace_lshift */
        0,                              /* nb_inplace_rshift */
        0,                              /* nb_inplace_and */
        0,                              /* nb_inplace_xor */
        0,                              /* nb_inplace_or */
        0,                              /* nb_floor_divide */
        0,                              /* nb_true_divide */
        0,                              /* nb_inplace_floor_divide */
        0,                              /* nb_inplace_true_divide */
        0,                              /* nb_index */
};

static PyTypeObject KeyIterator_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                         /* ob_size */
    "pyregfi.KeyIterator",               /* tp_name */
    sizeof(pyKeyIterator),            /* tp_basicsize */
    0,                         /* tp_itemsize */
    (destructor)KeyIterator_dealloc,/* tp_dealloc */
    0,                         /* tp_print */
    0,                         /* tp_getattr */
    0,                         /* tp_setattr */
    0,                         /* tp_compare */
    0,                         /* tp_repr */
    &KeyIterator_as_number,      /* tp_as_number */
    0,                         /* tp_as_sequence */
    0,                         /* tp_as_mapping */
    0,                         /* tp_hash */
    0,                         /* tp_call */
    (reprfunc)0,      /* tp_str */
    (getattrofunc)pyKeyIterator_getattr,                         /* tp_getattro */
    0,                         /* tp_setattro */
    0,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,        /* tp_flags */
    "KeyIterator:  This is an iterator for reading keys from the registry ",     /* tp_doc */
    0,	                       /* tp_traverse */
    0,                         /* tp_clear */
    0,                         /* tp_richcompare */
    0,                         /* tp_weaklistoffset */
    (getiterfunc)pyKeyIterator___iter__,              /* tp_iter */
    (iternextfunc)pyKeyIterator_iternext,/* tp_iternext */
    KeyIterator_methods,         /* tp_methods */
    0,                         /* tp_members */
    0,                         /* tp_getset */
    0,                         /* tp_base */
    0,                         /* tp_dict */
    0,                         /* tp_descr_get */
    0,                         /* tp_descr_set */
    0,                         /* tp_dictoffset */
    (initproc)pyKeyIterator_init,      /* tp_init */
    0,                         /* tp_alloc */
    0,                         /* tp_new */
};
static PyMethodDef Object_methods[] = {
     {NULL}  /* Sentinel */
};
static void
Object_dealloc(pyObject *self) {

    if(self->base) {
        //printf("Unlinking %s@%p\n", NAMEOF(self->base), self->base);
        talloc_free(self->ctx);
        self->base=NULL;
    };

 PyObject_Del(self);
};

static int pyObject_init(pyObject *self, PyObject *args, PyObject *kwds) {
return 0;};


static PyObject *pyObject_getattr(pyObject *self, PyObject *pyname) {
  char *name;
  // Try to hand it off to the python native handler first
  PyObject *result = PyObject_GenericGetAttr((PyObject*)self, pyname);

  if(result) return result;

  PyErr_Clear();
  // No - nothing interesting was found by python
  name = PyString_AsString(pyname);

  if(!self->base) return PyErr_Format(PyExc_RuntimeError, "Wrapped object (Object.pyObject_getattr) no longer valid");
  if(!name) return NULL;
  if(!strcmp(name, "__members__")) {
     PyObject *result = PyList_New(0);
     PyObject *tmp;
     PyMethodDef *i;

     if(!result) goto error;


    for(i=Object_methods; i->ml_name; i++) {
     tmp = PyString_FromString(i->ml_name);
    PyList_Append(result, tmp); Py_DECREF(tmp);
    }; 
     return result; 
   }


  return PyObject_GenericGetAttr((PyObject *)self, pyname);
error:
return NULL;
}


static int
Object_nonzero(pyObject *v)
{
        return v->base != 0;
};

static PyNumberMethods Object_as_number = {
        (binaryfunc)    0,       /*nb_add*/
        (binaryfunc)    0,       /*nb_subtract*/
        (binaryfunc)    0,       /*nb_multiply*/
                        0,       /*nb_divide*/
                        0,       /*nb_remainder*/
                        0,       /*nb_divmod*/
                        0,       /*nb_power*/
        (unaryfunc)     0,       /*nb_negative*/
        (unaryfunc)     0,       /*tp_positive*/
        (unaryfunc)     0,       /*tp_absolute*/
        (inquiry)       Object_nonzero,   /*tp_nonzero*/
        (unaryfunc)     0,       /*nb_invert*/
                        0,       /*nb_lshift*/
        (binaryfunc)    0,       /*nb_rshift*/
                        0,       /*nb_and*/
                        0,       /*nb_xor*/
                        0,       /*nb_or*/
                        0,       /*nb_coerce*/
         (unaryfunc)    0,       /*nb_int*/
                        0,       /*nb_long*/
                        0,       /*nb_float*/
                        0,       /*nb_oct*/
                        0,       /*nb_hex*/
        0,                              /* nb_inplace_add */
        0,                              /* nb_inplace_subtract */
        0,                              /* nb_inplace_multiply */
        0,                              /* nb_inplace_divide */
        0,                              /* nb_inplace_remainder */
        0,                              /* nb_inplace_power */
        0,                              /* nb_inplace_lshift */
        0,                              /* nb_inplace_rshift */
        0,                              /* nb_inplace_and */
        0,                              /* nb_inplace_xor */
        0,                              /* nb_inplace_or */
        0,                              /* nb_floor_divide */
        0,                              /* nb_true_divide */
        0,                              /* nb_inplace_floor_divide */
        0,                              /* nb_inplace_true_divide */
        0,                              /* nb_index */
};

static PyTypeObject Object_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                         /* ob_size */
    "pyregfi.Object",               /* tp_name */
    sizeof(pyObject),            /* tp_basicsize */
    0,                         /* tp_itemsize */
    (destructor)Object_dealloc,/* tp_dealloc */
    0,                         /* tp_print */
    0,                         /* tp_getattr */
    0,                         /* tp_setattr */
    0,                         /* tp_compare */
    0,                         /* tp_repr */
    &Object_as_number,      /* tp_as_number */
    0,                         /* tp_as_sequence */
    0,                         /* tp_as_mapping */
    0,                         /* tp_hash */
    0,                         /* tp_call */
    (reprfunc)0,      /* tp_str */
    (getattrofunc)pyObject_getattr,                         /* tp_getattro */
    0,                         /* tp_setattro */
    0,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,        /* tp_flags */
    "Object:  Base object\n",     /* tp_doc */
    0,	                       /* tp_traverse */
    0,                         /* tp_clear */
    0,                         /* tp_richcompare */
    0,                         /* tp_weaklistoffset */
    (getiterfunc)0,              /* tp_iter */
    (iternextfunc)0,/* tp_iternext */
    Object_methods,         /* tp_methods */
    0,                         /* tp_members */
    0,                         /* tp_getset */
    0,                         /* tp_base */
    0,                         /* tp_dict */
    0,                         /* tp_descr_get */
    0,                         /* tp_descr_set */
    0,                         /* tp_dictoffset */
    (initproc)pyObject_init,      /* tp_init */
    0,                         /* tp_alloc */
    0,                         /* tp_new */
};
static PyMethodDef RegistryFile_methods[] = {
     {"get_key",(PyCFunction)pyRegistryFile_get_key, METH_VARARGS|METH_KEYWORDS, "KeyIterator RegistryFile.get_key(char ** path ,REGFI_ENCODING encoding );\n\n\nGet an iterator for a specific path in the register if path is\n     specified.\n\n     DEFAULT(path) == NULL;\n     DEFAULT(encoding) = REGFI_ENCODING_ASCII;\n  "},
     {"set_log_mask",(PyCFunction)pyRegistryFile_set_log_mask, METH_VARARGS|METH_KEYWORDS, "int RegistryFile.set_log_mask(uint16_t mask );\n\n\n Set the verbosity level of messages generated by the library for the \n *  current thread.\n *\n * @param mask   An integer representing the types of messages desired.\n *               Acceptable values are created through bitwise ORs of \n *               REGFI_LOG_* values.  For instance, if only errors and\n *               informational messages were desired (but not warnings),\n *               then one would specify: REGFI_LOG_ERROR|REGFI_LOG_INFO\n *               By default the message mask is: REGFI_LOG_ERROR|REGFI_LOG_WARN.\n *\n * @return       true on success and false on failure.  Failure occurs if \n *               underlying pthread functions fail.  errno is set in this case.\n *\n * Message masks are set in a thread-specific way.  If one were to set a message\n * mask in one thread and then spawn a new thread, then the new thread will have\n * it\'s message mask reset to the default.  This function may be called at any \n * time and will take effect immediately for the current thread.\n *\n * @note When a non-zero message mask is set, messages will\n *       accumulate in memory without limit if they are not fetched using\n *       @ref regfi_get_log_str and subsequently freed by the caller.  It is\n *       recommended that messsages be fetched after each regfi API call in\n *       order to provide the most context.\n *\n * @ingroup regfiBase\n "},
     {NULL}  /* Sentinel */
};
static void
RegistryFile_dealloc(pyRegistryFile *self) {

    if(self->base) {
        //printf("Unlinking %s@%p\n", NAMEOF(self->base), self->base);
        talloc_free(self->ctx);
        self->base=NULL;
    };

 PyObject_Del(self);
};


static int pyRegistryFile_init(pyRegistryFile *self, PyObject *args, PyObject *kwds)
{
char * __attribute__((unused)) filename;
static char *kwlist[] = {"filename", NULL};

if(!PyArg_ParseTupleAndKeywords(args, kwds, "s|", kwlist, &filename))
 goto error;


self->ctx = talloc_strdup(NULL, "RegistryFile");
 ClearError();
Py_BEGIN_ALLOW_THREADS
self->base = CONSTRUCT(RegistryFile, RegistryFile, Con, self->ctx, filename);
Py_END_ALLOW_THREADS

       if(!CheckError(EZero)) {
         char *buffer;
         PyObject *exception = resolve_exception(&buffer);

         PyErr_Format(exception,
                    "%s", buffer);
         ClearError();
         goto error;
  } else if(!self->base) {
    PyErr_Format(PyExc_IOError, "Unable to construct class RegistryFile");
    goto error;
  };
  return 0;
error:
    return -1;
};


static PyObject *pyRegistryFile_getattr(pyRegistryFile *self, PyObject *pyname) {
  char *name;
  // Try to hand it off to the python native handler first
  PyObject *result = PyObject_GenericGetAttr((PyObject*)self, pyname);

  if(result) return result;

  PyErr_Clear();
  // No - nothing interesting was found by python
  name = PyString_AsString(pyname);

  if(!self->base) return PyErr_Format(PyExc_RuntimeError, "Wrapped object (RegistryFile.pyRegistryFile_getattr) no longer valid");
  if(!name) return NULL;
  if(!strcmp(name, "__members__")) {
     PyObject *result = PyList_New(0);
     PyObject *tmp;
     PyMethodDef *i;

     if(!result) goto error;
 tmp = PyString_FromString("fd");
    PyList_Append(result, tmp); Py_DECREF(tmp);


    for(i=RegistryFile_methods; i->ml_name; i++) {
     tmp = PyString_FromString(i->ml_name);
    PyList_Append(result, tmp); Py_DECREF(tmp);
    }; 
     return result; 
   }

if(!strcmp(name, "fd")) {
    PyObject *py_result;
    uint64_t __attribute__((unused)) fd;


    Py_BEGIN_ALLOW_THREADS
fd = (((RegistryFile)self->base)->fd);
Py_END_ALLOW_THREADS

    PyErr_Clear();
py_result = PyLong_FromLongLong(fd);

    return py_result;
};

  return PyObject_GenericGetAttr((PyObject *)self, pyname);
error:
return NULL;
}


/********************************************************
Autogenerated wrapper for function:
KeyIterator RegistryFile.get_key(char ** path ,REGFI_ENCODING encoding );
********************************************************/
static PyObject *pyRegistryFile_get_key(pyRegistryFile *self, PyObject *args, PyObject *kwds) {
       PyObject *returned_result, *py_result;
Gen_wrapper *func_return __attribute__((unused)) = NULL;
char **path=NULL; PyObject *py_path=NULL;
REGFI_ENCODING encoding= REGFI_ENCODING_ASCII;;
static char *kwlist[] = {"path","encoding", NULL};

if(!PyArg_ParseTupleAndKeywords(args, kwds, "|Oi", kwlist, &py_path,&encoding))
 goto error;

// Make sure that we have something valid to wrap
if(!self->base) return PyErr_Format(PyExc_RuntimeError, "RegistryFile object no longer valid");
// Precall preparations
{
Py_ssize_t i,size=0;

if(py_path) {
   if(!PySequence_Check(py_path)) {
     PyErr_Format(PyExc_ValueError, "path must be a sequence");
     goto error;
   };

   size = PySequence_Size(py_path);
};

path = talloc_zero_array(NULL, char *, size + 1);

for(i=0; i<size;i++) {
 PyObject *tmp = PySequence_GetItem(py_path, i);
 if(!tmp) goto error;
 path[i] = PyString_AsString(tmp);
 if(!path[i]) {
   Py_DECREF(tmp);
   goto error;
 };
 Py_DECREF(tmp);
};

};
// Check if the integer passed is actually a valid member of the enum
// Enum value of 0 is always allowed
if(encoding) { PyObject *py_encoding = PyLong_FromLong(encoding);
  PyObject *tmp = PyDict_GetItem(REGFI_ENCODING_rev_lookup, py_encoding);

  Py_DECREF(py_encoding);
  if(!tmp) {
    PyErr_Format(PyExc_RuntimeError, "value %lu is not valid for Enum REGFI_ENCODING of arg 'encoding'", (unsigned long)encoding);
    goto error;
  };
  Py_DECREF(tmp);
};
// Check the function is implemented
  {  void *method = ((RegistryFile)self->base)->get_key;
     if(!method || (void *)unimplemented == (void *)method) {
         PyErr_Format(PyExc_RuntimeError, "RegistryFile.get_key is not implemented");
         goto error;
     };
  };

// Make the call
 ClearError();{
       Object returned_object;

       ClearError();

       Py_BEGIN_ALLOW_THREADS
       returned_object = (Object)((RegistryFile)self->base)->get_key(((RegistryFile)self->base), path, encoding);
       Py_END_ALLOW_THREADS

       CHECK_ERROR;

       // A NULL return without errors means we return None
       if(!returned_object) {
         func_return = (Gen_wrapper *)Py_None;
         Py_INCREF(Py_None);

       } else {
         //printf("%s: Wrapping %s@%p\n", __FUNCTION__, NAMEOF(returned_object), returned_object);
         func_return = new_class_wrapper(returned_object);
         if(!func_return) goto error;
       };
    }

// Postcall preparations

// prepare results
py_result = (PyObject *)func_return;
returned_result = py_result;
return returned_result;

// error conditions:
error:
    return NULL;

};


/********************************************************
Autogenerated wrapper for function:
int RegistryFile.set_log_mask(uint16_t mask );
********************************************************/
static PyObject *pyRegistryFile_set_log_mask(pyRegistryFile *self, PyObject *args, PyObject *kwds) {
       PyObject *returned_result, *py_result;
uint64_t __attribute__((unused)) func_return;
uint64_t __attribute__((unused)) mask;
static char *kwlist[] = {"mask", NULL};

if(!PyArg_ParseTupleAndKeywords(args, kwds, "K|", kwlist, &mask))
 goto error;

// Make sure that we have something valid to wrap
if(!self->base) return PyErr_Format(PyExc_RuntimeError, "RegistryFile object no longer valid");
// Precall preparations
// Check the function is implemented
  {  void *method = ((RegistryFile)self->base)->set_log_mask;
     if(!method || (void *)unimplemented == (void *)method) {
         PyErr_Format(PyExc_RuntimeError, "RegistryFile.set_log_mask is not implemented");
         goto error;
     };
  };

// Make the call
 ClearError();Py_BEGIN_ALLOW_THREADS
func_return = ((RegistryFile)self->base)->set_log_mask(((RegistryFile)self->base), mask);
Py_END_ALLOW_THREADS

// Postcall preparations

// prepare results
PyErr_Clear();
py_result = PyLong_FromLongLong(func_return);
returned_result = py_result;
return returned_result;

// error conditions:
error:
    return NULL;

};


static int
RegistryFile_nonzero(pyRegistryFile *v)
{
        return v->base != 0;
};

static PyNumberMethods RegistryFile_as_number = {
        (binaryfunc)    0,       /*nb_add*/
        (binaryfunc)    0,       /*nb_subtract*/
        (binaryfunc)    0,       /*nb_multiply*/
                        0,       /*nb_divide*/
                        0,       /*nb_remainder*/
                        0,       /*nb_divmod*/
                        0,       /*nb_power*/
        (unaryfunc)     0,       /*nb_negative*/
        (unaryfunc)     0,       /*tp_positive*/
        (unaryfunc)     0,       /*tp_absolute*/
        (inquiry)       RegistryFile_nonzero,   /*tp_nonzero*/
        (unaryfunc)     0,       /*nb_invert*/
                        0,       /*nb_lshift*/
        (binaryfunc)    0,       /*nb_rshift*/
                        0,       /*nb_and*/
                        0,       /*nb_xor*/
                        0,       /*nb_or*/
                        0,       /*nb_coerce*/
         (unaryfunc)    0,       /*nb_int*/
                        0,       /*nb_long*/
                        0,       /*nb_float*/
                        0,       /*nb_oct*/
                        0,       /*nb_hex*/
        0,                              /* nb_inplace_add */
        0,                              /* nb_inplace_subtract */
        0,                              /* nb_inplace_multiply */
        0,                              /* nb_inplace_divide */
        0,                              /* nb_inplace_remainder */
        0,                              /* nb_inplace_power */
        0,                              /* nb_inplace_lshift */
        0,                              /* nb_inplace_rshift */
        0,                              /* nb_inplace_and */
        0,                              /* nb_inplace_xor */
        0,                              /* nb_inplace_or */
        0,                              /* nb_floor_divide */
        0,                              /* nb_true_divide */
        0,                              /* nb_inplace_floor_divide */
        0,                              /* nb_inplace_true_divide */
        0,                              /* nb_index */
};

static PyTypeObject RegistryFile_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                         /* ob_size */
    "pyregfi.RegistryFile",               /* tp_name */
    sizeof(pyRegistryFile),            /* tp_basicsize */
    0,                         /* tp_itemsize */
    (destructor)RegistryFile_dealloc,/* tp_dealloc */
    0,                         /* tp_print */
    0,                         /* tp_getattr */
    0,                         /* tp_setattr */
    0,                         /* tp_compare */
    0,                         /* tp_repr */
    &RegistryFile_as_number,      /* tp_as_number */
    0,                         /* tp_as_sequence */
    0,                         /* tp_as_mapping */
    0,                         /* tp_hash */
    0,                         /* tp_call */
    (reprfunc)0,      /* tp_str */
    (getattrofunc)pyRegistryFile_getattr,                         /* tp_getattro */
    0,                         /* tp_setattro */
    0,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,        /* tp_flags */
    "RegistryFile: ",     /* tp_doc */
    0,	                       /* tp_traverse */
    0,                         /* tp_clear */
    0,                         /* tp_richcompare */
    0,                         /* tp_weaklistoffset */
    (getiterfunc)0,              /* tp_iter */
    (iternextfunc)0,/* tp_iternext */
    RegistryFile_methods,         /* tp_methods */
    0,                         /* tp_members */
    0,                         /* tp_getset */
    0,                         /* tp_base */
    0,                         /* tp_dict */
    0,                         /* tp_descr_get */
    0,                         /* tp_descr_set */
    0,                         /* tp_dictoffset */
    (initproc)pyRegistryFile_init,      /* tp_init */
    0,                         /* tp_alloc */
    0,                         /* tp_new */
};
static PyMethodDef DataString_methods[] = {
     {"get_value",(PyCFunction)pyDataString_get_value, METH_VARARGS|METH_KEYWORDS, "BORROWED char * DataString.get_value();\n\n\n"},
     {NULL}  /* Sentinel */
};
static void
DataString_dealloc(pyDataString *self) {

    if(self->base) {
        //printf("Unlinking %s@%p\n", NAMEOF(self->base), self->base);
        talloc_free(self->ctx);
        self->base=NULL;
    };

 PyObject_Del(self);
};


static int pyDataString_init(pyDataString *self, PyObject *args, PyObject *kwds)
{
Gen_wrapper *data = NULL; REGFI_DATA *call_data;
Gen_wrapper *record = NULL; REGFI_VK_REC *call_record;
static char *kwlist[] = {"data","record", NULL};

if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO|", kwlist, &data,&record))
 goto error;


if(!data || (PyObject *)data==Py_None) {
   call_data = NULL;
} else if(!type_check((PyObject *)data,&REGFI_DATA_Type)) {
     PyErr_Format(PyExc_RuntimeError, "data must be derived from type REGFI_DATA");
     goto error;
} else {
   call_data = data->base;
};

if(!record || (PyObject *)record==Py_None) {
   call_record = NULL;
} else if(!type_check((PyObject *)record,&REGFI_VK_REC_Type)) {
     PyErr_Format(PyExc_RuntimeError, "record must be derived from type REGFI_VK_REC");
     goto error;
} else {
   call_record = record->base;
};

self->ctx = talloc_strdup(NULL, "DataString");
 ClearError();
Py_BEGIN_ALLOW_THREADS
self->base = CONSTRUCT(DataString, RawData, Con, self->ctx, call_data, call_record);
Py_END_ALLOW_THREADS

       if(!CheckError(EZero)) {
         char *buffer;
         PyObject *exception = resolve_exception(&buffer);

         PyErr_Format(exception,
                    "%s", buffer);
         ClearError();
         goto error;
  } else if(!self->base) {
    PyErr_Format(PyExc_IOError, "Unable to construct class DataString");
    goto error;
  };
  return 0;
error:
    return -1;
};


static PyObject *pyDataString_getattr(pyDataString *self, PyObject *pyname) {
  char *name;
  // Try to hand it off to the python native handler first
  PyObject *result = PyObject_GenericGetAttr((PyObject*)self, pyname);

  if(result) return result;

  PyErr_Clear();
  // No - nothing interesting was found by python
  name = PyString_AsString(pyname);

  if(!self->base) return PyErr_Format(PyExc_RuntimeError, "Wrapped object (DataString.pyDataString_getattr) no longer valid");
  if(!name) return NULL;
  if(!strcmp(name, "__members__")) {
     PyObject *result = PyList_New(0);
     PyObject *tmp;
     PyMethodDef *i;

     if(!result) goto error;
 tmp = PyString_FromString("data");
    PyList_Append(result, tmp); Py_DECREF(tmp);
 tmp = PyString_FromString("rec");
    PyList_Append(result, tmp); Py_DECREF(tmp);


    for(i=DataString_methods; i->ml_name; i++) {
     tmp = PyString_FromString(i->ml_name);
    PyList_Append(result, tmp); Py_DECREF(tmp);
    }; 
     return result; 
   }

if(!strcmp(name, "data")) {
    PyObject *py_result;
    Gen_wrapper *data = NULL;

    
PyErr_Clear();
data = (Gen_wrapper *)PyObject_New(pyREGFI_DATA, &REGFI_DATA_Type);
data->ctx = talloc_size(NULL, 1);
data->base = (((RawData)self->base)->data);

// A NULL object gets translated to a None
 if(!data->base) {
   Py_DECREF(data);
   Py_INCREF(Py_None);
   data = (Gen_wrapper *)Py_None;
 } else {
talloc_reference(data->ctx, data->base);
}

    py_result = (PyObject *)data;

    return py_result;
};
if(!strcmp(name, "rec")) {
    PyObject *py_result;
    Gen_wrapper *rec = NULL;

    
PyErr_Clear();
rec = (Gen_wrapper *)PyObject_New(pyREGFI_VK_REC, &REGFI_VK_REC_Type);
rec->ctx = talloc_size(NULL, 1);
rec->base = (((RawData)self->base)->rec);

// A NULL object gets translated to a None
 if(!rec->base) {
   Py_DECREF(rec);
   Py_INCREF(Py_None);
   rec = (Gen_wrapper *)Py_None;
 } else {
talloc_reference(rec->ctx, rec->base);
}

    py_result = (PyObject *)rec;

    return py_result;
};

  return PyObject_GenericGetAttr((PyObject *)self, pyname);
error:
return NULL;
}


/********************************************************
Autogenerated wrapper for function:
BORROWED char * DataString.get_value();
********************************************************/
static PyObject *pyDataString_get_value(pyDataString *self, PyObject *args, PyObject *kwds) {
       PyObject *returned_result, *py_result;
char * __attribute__((unused)) func_return;
// Make sure that we have something valid to wrap
if(!self->base) return PyErr_Format(PyExc_RuntimeError, "DataString object no longer valid");
// Precall preparations
// Check the function is implemented
  {  void *method = ((DataString)self->base)->get_value;
     if(!method || (void *)unimplemented == (void *)method) {
         PyErr_Format(PyExc_RuntimeError, "DataString.get_value is not implemented");
         goto error;
     };
  };

// Make the call
 ClearError();Py_BEGIN_ALLOW_THREADS
func_return = ((DataString)self->base)->get_value(((DataString)self->base));
Py_END_ALLOW_THREADS

// Postcall preparations

// prepare results
PyErr_Clear();
   if(!func_return) { PyErr_Format(PyExc_RuntimeError, "func_return is NULL"); goto error; };
   py_result = PyString_FromStringAndSize((char *)func_return, strlen(func_return));
if(!py_result) goto error;
returned_result = py_result;
return returned_result;

// error conditions:
error:
    return NULL;

};


static int
DataString_nonzero(pyDataString *v)
{
        return v->base != 0;
};

static PyNumberMethods DataString_as_number = {
        (binaryfunc)    0,       /*nb_add*/
        (binaryfunc)    0,       /*nb_subtract*/
        (binaryfunc)    0,       /*nb_multiply*/
                        0,       /*nb_divide*/
                        0,       /*nb_remainder*/
                        0,       /*nb_divmod*/
                        0,       /*nb_power*/
        (unaryfunc)     0,       /*nb_negative*/
        (unaryfunc)     0,       /*tp_positive*/
        (unaryfunc)     0,       /*tp_absolute*/
        (inquiry)       DataString_nonzero,   /*tp_nonzero*/
        (unaryfunc)     0,       /*nb_invert*/
                        0,       /*nb_lshift*/
        (binaryfunc)    0,       /*nb_rshift*/
                        0,       /*nb_and*/
                        0,       /*nb_xor*/
                        0,       /*nb_or*/
                        0,       /*nb_coerce*/
         (unaryfunc)    0,       /*nb_int*/
                        0,       /*nb_long*/
                        0,       /*nb_float*/
                        0,       /*nb_oct*/
                        0,       /*nb_hex*/
        0,                              /* nb_inplace_add */
        0,                              /* nb_inplace_subtract */
        0,                              /* nb_inplace_multiply */
        0,                              /* nb_inplace_divide */
        0,                              /* nb_inplace_remainder */
        0,                              /* nb_inplace_power */
        0,                              /* nb_inplace_lshift */
        0,                              /* nb_inplace_rshift */
        0,                              /* nb_inplace_and */
        0,                              /* nb_inplace_xor */
        0,                              /* nb_inplace_or */
        0,                              /* nb_floor_divide */
        0,                              /* nb_true_divide */
        0,                              /* nb_inplace_floor_divide */
        0,                              /* nb_inplace_true_divide */
        0,                              /* nb_index */
};

static PyTypeObject DataString_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                         /* ob_size */
    "pyregfi.DataString",               /* tp_name */
    sizeof(pyDataString),            /* tp_basicsize */
    0,                         /* tp_itemsize */
    (destructor)DataString_dealloc,/* tp_dealloc */
    0,                         /* tp_print */
    0,                         /* tp_getattr */
    0,                         /* tp_setattr */
    0,                         /* tp_compare */
    0,                         /* tp_repr */
    &DataString_as_number,      /* tp_as_number */
    0,                         /* tp_as_sequence */
    0,                         /* tp_as_mapping */
    0,                         /* tp_hash */
    0,                         /* tp_call */
    (reprfunc)0,      /* tp_str */
    (getattrofunc)pyDataString_getattr,                         /* tp_getattro */
    0,                         /* tp_setattro */
    0,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,        /* tp_flags */
    "DataString: ",     /* tp_doc */
    0,	                       /* tp_traverse */
    0,                         /* tp_clear */
    0,                         /* tp_richcompare */
    0,                         /* tp_weaklistoffset */
    (getiterfunc)0,              /* tp_iter */
    (iternextfunc)0,/* tp_iternext */
    DataString_methods,         /* tp_methods */
    0,                         /* tp_members */
    0,                         /* tp_getset */
    0,                         /* tp_base */
    0,                         /* tp_dict */
    0,                         /* tp_descr_get */
    0,                         /* tp_descr_set */
    0,                         /* tp_dictoffset */
    (initproc)pyDataString_init,      /* tp_init */
    0,                         /* tp_alloc */
    0,                         /* tp_new */
};
static PyMethodDef RawData_methods[] = {
     {"get_value",(PyCFunction)pyRawData_get_value, METH_VARARGS|METH_KEYWORDS, "int RawData.get_value(OUT char * buffer, int len);\n\n\n Return the raw buffer as a string. By default we only return\n        this much data - specify a required length to return more.\n\n        DEFAULT(len) = 4096;\n    "},
     {NULL}  /* Sentinel */
};
static void
RawData_dealloc(pyRawData *self) {

    if(self->base) {
        //printf("Unlinking %s@%p\n", NAMEOF(self->base), self->base);
        talloc_free(self->ctx);
        self->base=NULL;
    };

 PyObject_Del(self);
};


static int pyRawData_init(pyRawData *self, PyObject *args, PyObject *kwds)
{
Gen_wrapper *data = NULL; REGFI_DATA *call_data;
Gen_wrapper *record = NULL; REGFI_VK_REC *call_record;
static char *kwlist[] = {"data","record", NULL};

if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO|", kwlist, &data,&record))
 goto error;


if(!data || (PyObject *)data==Py_None) {
   call_data = NULL;
} else if(!type_check((PyObject *)data,&REGFI_DATA_Type)) {
     PyErr_Format(PyExc_RuntimeError, "data must be derived from type REGFI_DATA");
     goto error;
} else {
   call_data = data->base;
};

if(!record || (PyObject *)record==Py_None) {
   call_record = NULL;
} else if(!type_check((PyObject *)record,&REGFI_VK_REC_Type)) {
     PyErr_Format(PyExc_RuntimeError, "record must be derived from type REGFI_VK_REC");
     goto error;
} else {
   call_record = record->base;
};

self->ctx = talloc_strdup(NULL, "RawData");
 ClearError();
Py_BEGIN_ALLOW_THREADS
self->base = CONSTRUCT(RawData, RawData, Con, self->ctx, call_data, call_record);
Py_END_ALLOW_THREADS

       if(!CheckError(EZero)) {
         char *buffer;
         PyObject *exception = resolve_exception(&buffer);

         PyErr_Format(exception,
                    "%s", buffer);
         ClearError();
         goto error;
  } else if(!self->base) {
    PyErr_Format(PyExc_IOError, "Unable to construct class RawData");
    goto error;
  };
  return 0;
error:
    return -1;
};


static PyObject *pyRawData_getattr(pyRawData *self, PyObject *pyname) {
  char *name;
  // Try to hand it off to the python native handler first
  PyObject *result = PyObject_GenericGetAttr((PyObject*)self, pyname);

  if(result) return result;

  PyErr_Clear();
  // No - nothing interesting was found by python
  name = PyString_AsString(pyname);

  if(!self->base) return PyErr_Format(PyExc_RuntimeError, "Wrapped object (RawData.pyRawData_getattr) no longer valid");
  if(!name) return NULL;
  if(!strcmp(name, "__members__")) {
     PyObject *result = PyList_New(0);
     PyObject *tmp;
     PyMethodDef *i;

     if(!result) goto error;
 tmp = PyString_FromString("data");
    PyList_Append(result, tmp); Py_DECREF(tmp);
 tmp = PyString_FromString("rec");
    PyList_Append(result, tmp); Py_DECREF(tmp);


    for(i=RawData_methods; i->ml_name; i++) {
     tmp = PyString_FromString(i->ml_name);
    PyList_Append(result, tmp); Py_DECREF(tmp);
    }; 
     return result; 
   }

if(!strcmp(name, "data")) {
    PyObject *py_result;
    Gen_wrapper *data = NULL;

    
PyErr_Clear();
data = (Gen_wrapper *)PyObject_New(pyREGFI_DATA, &REGFI_DATA_Type);
data->ctx = talloc_size(NULL, 1);
data->base = (((RawData)self->base)->data);

// A NULL object gets translated to a None
 if(!data->base) {
   Py_DECREF(data);
   Py_INCREF(Py_None);
   data = (Gen_wrapper *)Py_None;
 } else {
talloc_reference(data->ctx, data->base);
}

    py_result = (PyObject *)data;

    return py_result;
};
if(!strcmp(name, "rec")) {
    PyObject *py_result;
    Gen_wrapper *rec = NULL;

    
PyErr_Clear();
rec = (Gen_wrapper *)PyObject_New(pyREGFI_VK_REC, &REGFI_VK_REC_Type);
rec->ctx = talloc_size(NULL, 1);
rec->base = (((RawData)self->base)->rec);

// A NULL object gets translated to a None
 if(!rec->base) {
   Py_DECREF(rec);
   Py_INCREF(Py_None);
   rec = (Gen_wrapper *)Py_None;
 } else {
talloc_reference(rec->ctx, rec->base);
}

    py_result = (PyObject *)rec;

    return py_result;
};

  return PyObject_GenericGetAttr((PyObject *)self, pyname);
error:
return NULL;
}


/********************************************************
Autogenerated wrapper for function:
int RawData.get_value(OUT char * buffer, int len);
********************************************************/
static PyObject *pyRawData_get_value(pyRawData *self, PyObject *args, PyObject *kwds) {
       PyObject *returned_result, *py_result;
uint64_t __attribute__((unused)) func_return;
char *buffer=NULL; Py_ssize_t len= 4096;;
PyObject *tmp_buffer;
static char *kwlist[] = {"len", NULL};

if(!PyArg_ParseTupleAndKeywords(args, kwds, "|l", kwlist, &len))
 goto error;

// Make sure that we have something valid to wrap
if(!self->base) return PyErr_Format(PyExc_RuntimeError, "RawData object no longer valid");
// Precall preparations
PyErr_Clear();
tmp_buffer = PyString_FromStringAndSize(NULL, len);
if(!tmp_buffer) goto error;
PyString_AsStringAndSize(tmp_buffer, &buffer, (Py_ssize_t *)&len);
// Check the function is implemented
  {  void *method = ((RawData)self->base)->get_value;
     if(!method || (void *)unimplemented == (void *)method) {
         PyErr_Format(PyExc_RuntimeError, "RawData.get_value is not implemented");
         goto error;
     };
  };

// Make the call
 ClearError();Py_BEGIN_ALLOW_THREADS
func_return = ((RawData)self->base)->get_value(((RawData)self->base), (OUT char *)buffer, (int)len);
Py_END_ALLOW_THREADS

// Postcall preparations

// prepare results
if(func_return > len) {
  func_return = 0;
};

_PyString_Resize(&tmp_buffer, func_return); 
py_result = tmp_buffer;
returned_result = py_result;
return returned_result;

// error conditions:
error:
    return NULL;

};


static int
RawData_nonzero(pyRawData *v)
{
        return v->base != 0;
};

static PyNumberMethods RawData_as_number = {
        (binaryfunc)    0,       /*nb_add*/
        (binaryfunc)    0,       /*nb_subtract*/
        (binaryfunc)    0,       /*nb_multiply*/
                        0,       /*nb_divide*/
                        0,       /*nb_remainder*/
                        0,       /*nb_divmod*/
                        0,       /*nb_power*/
        (unaryfunc)     0,       /*nb_negative*/
        (unaryfunc)     0,       /*tp_positive*/
        (unaryfunc)     0,       /*tp_absolute*/
        (inquiry)       RawData_nonzero,   /*tp_nonzero*/
        (unaryfunc)     0,       /*nb_invert*/
                        0,       /*nb_lshift*/
        (binaryfunc)    0,       /*nb_rshift*/
                        0,       /*nb_and*/
                        0,       /*nb_xor*/
                        0,       /*nb_or*/
                        0,       /*nb_coerce*/
         (unaryfunc)    0,       /*nb_int*/
                        0,       /*nb_long*/
                        0,       /*nb_float*/
                        0,       /*nb_oct*/
                        0,       /*nb_hex*/
        0,                              /* nb_inplace_add */
        0,                              /* nb_inplace_subtract */
        0,                              /* nb_inplace_multiply */
        0,                              /* nb_inplace_divide */
        0,                              /* nb_inplace_remainder */
        0,                              /* nb_inplace_power */
        0,                              /* nb_inplace_lshift */
        0,                              /* nb_inplace_rshift */
        0,                              /* nb_inplace_and */
        0,                              /* nb_inplace_xor */
        0,                              /* nb_inplace_or */
        0,                              /* nb_floor_divide */
        0,                              /* nb_true_divide */
        0,                              /* nb_inplace_floor_divide */
        0,                              /* nb_inplace_true_divide */
        0,                              /* nb_index */
};

static PyTypeObject RawData_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                         /* ob_size */
    "pyregfi.RawData",               /* tp_name */
    sizeof(pyRawData),            /* tp_basicsize */
    0,                         /* tp_itemsize */
    (destructor)RawData_dealloc,/* tp_dealloc */
    0,                         /* tp_print */
    0,                         /* tp_getattr */
    0,                         /* tp_setattr */
    0,                         /* tp_compare */
    0,                         /* tp_repr */
    &RawData_as_number,      /* tp_as_number */
    0,                         /* tp_as_sequence */
    0,                         /* tp_as_mapping */
    0,                         /* tp_hash */
    0,                         /* tp_call */
    (reprfunc)0,      /* tp_str */
    (getattrofunc)pyRawData_getattr,                         /* tp_getattro */
    0,                         /* tp_setattro */
    0,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,        /* tp_flags */
    "RawData:  This is the base class for data objects ",     /* tp_doc */
    0,	                       /* tp_traverse */
    0,                         /* tp_clear */
    0,                         /* tp_richcompare */
    0,                         /* tp_weaklistoffset */
    (getiterfunc)0,              /* tp_iter */
    (iternextfunc)0,/* tp_iternext */
    RawData_methods,         /* tp_methods */
    0,                         /* tp_members */
    0,                         /* tp_getset */
    0,                         /* tp_base */
    0,                         /* tp_dict */
    0,                         /* tp_descr_get */
    0,                         /* tp_descr_set */
    0,                         /* tp_dictoffset */
    (initproc)pyRawData_init,      /* tp_init */
    0,                         /* tp_alloc */
    0,                         /* tp_new */
};
static PyMethodDef REGFI_ENCODING_methods[] = {
     {NULL}  /* Sentinel */
};
static void
REGFI_ENCODING_dealloc(pyREGFI_ENCODING *self) {
 Py_DECREF(self->value);
 PyObject_Del(self);
};


static int pyREGFI_ENCODING_init(pyREGFI_ENCODING *self, PyObject *args, PyObject *kwds)
{
static char *kwlist[] = {"value", NULL};

if(!PyArg_ParseTupleAndKeywords(args, kwds, "O", kwlist, &self->value))
 goto error;

Py_INCREF(self->value);

  return 0;
error:
    return -1;
};

static PyObject *pyREGFI_ENCODING___str__(pyREGFI_ENCODING *self) {
  PyObject *result = PyDict_GetItem(REGFI_ENCODING_rev_lookup, self->value);

  if(result) {
     Py_INCREF(result);
 } else {
     result = PyObject_Str(self->value);
 };

 return result;
};


static PyObject *REGFI_ENCODING_int(pyREGFI_ENCODING *self) {
    Py_INCREF(self->value);
    return self->value;
};

static PyNumberMethods REGFI_ENCODING_as_number = {
        (binaryfunc)    0,       /*nb_add*/
        (binaryfunc)    0,       /*nb_subtract*/
        (binaryfunc)    0,       /*nb_multiply*/
                        0,       /*nb_divide*/
                        0,       /*nb_remainder*/
                        0,       /*nb_divmod*/
                        0,       /*nb_power*/
        (unaryfunc)     0,       /*nb_negative*/
        (unaryfunc)     0,       /*tp_positive*/
        (unaryfunc)     0,       /*tp_absolute*/
        (inquiry)       0,   /*tp_nonzero*/
        (unaryfunc)     0,       /*nb_invert*/
                        0,       /*nb_lshift*/
        (binaryfunc)    0,       /*nb_rshift*/
                        0,       /*nb_and*/
                        0,       /*nb_xor*/
                        0,       /*nb_or*/
                        0,       /*nb_coerce*/
         (unaryfunc)    REGFI_ENCODING_int,       /*nb_int*/
                        0,       /*nb_long*/
                        0,       /*nb_float*/
                        0,       /*nb_oct*/
                        0,       /*nb_hex*/
        0,                              /* nb_inplace_add */
        0,                              /* nb_inplace_subtract */
        0,                              /* nb_inplace_multiply */
        0,                              /* nb_inplace_divide */
        0,                              /* nb_inplace_remainder */
        0,                              /* nb_inplace_power */
        0,                              /* nb_inplace_lshift */
        0,                              /* nb_inplace_rshift */
        0,                              /* nb_inplace_and */
        0,                              /* nb_inplace_xor */
        0,                              /* nb_inplace_or */
        0,                              /* nb_floor_divide */
        0,                              /* nb_true_divide */
        0,                              /* nb_inplace_floor_divide */
        0,                              /* nb_inplace_true_divide */
        0,                              /* nb_index */
};

static PyTypeObject REGFI_ENCODING_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                         /* ob_size */
    "pyregfi.REGFI_ENCODING",               /* tp_name */
    sizeof(pyREGFI_ENCODING),            /* tp_basicsize */
    0,                         /* tp_itemsize */
    (destructor)REGFI_ENCODING_dealloc,/* tp_dealloc */
    0,                         /* tp_print */
    0,                         /* tp_getattr */
    0,                         /* tp_setattr */
    0,                         /* tp_compare */
    0,                         /* tp_repr */
    &REGFI_ENCODING_as_number,      /* tp_as_number */
    0,                         /* tp_as_sequence */
    0,                         /* tp_as_mapping */
    0,                         /* tp_hash */
    0,                         /* tp_call */
    (reprfunc)pyREGFI_ENCODING___str__,      /* tp_str */
    (getattrofunc)0,                         /* tp_getattro */
    0,                         /* tp_setattro */
    0,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,        /* tp_flags */
    "REGFI_ENCODING: ",     /* tp_doc */
    0,	                       /* tp_traverse */
    0,                         /* tp_clear */
    0,                         /* tp_richcompare */
    0,                         /* tp_weaklistoffset */
    (getiterfunc)0,              /* tp_iter */
    (iternextfunc)0,/* tp_iternext */
    REGFI_ENCODING_methods,         /* tp_methods */
    0,                         /* tp_members */
    0,                         /* tp_getset */
    0,                         /* tp_base */
    0,                         /* tp_dict */
    0,                         /* tp_descr_get */
    0,                         /* tp_descr_set */
    0,                         /* tp_dictoffset */
    (initproc)pyREGFI_ENCODING_init,      /* tp_init */
    0,                         /* tp_alloc */
    0,                         /* tp_new */
};
static PyMethodDef REGFI_DATA_TYPE_methods[] = {
     {NULL}  /* Sentinel */
};
static void
REGFI_DATA_TYPE_dealloc(pyREGFI_DATA_TYPE *self) {
 Py_DECREF(self->value);
 PyObject_Del(self);
};


static int pyREGFI_DATA_TYPE_init(pyREGFI_DATA_TYPE *self, PyObject *args, PyObject *kwds)
{
static char *kwlist[] = {"value", NULL};

if(!PyArg_ParseTupleAndKeywords(args, kwds, "O", kwlist, &self->value))
 goto error;

Py_INCREF(self->value);

  return 0;
error:
    return -1;
};

static PyObject *pyREGFI_DATA_TYPE___str__(pyREGFI_DATA_TYPE *self) {
  PyObject *result = PyDict_GetItem(REGFI_DATA_TYPE_rev_lookup, self->value);

  if(result) {
     Py_INCREF(result);
 } else {
     result = PyObject_Str(self->value);
 };

 return result;
};


static PyObject *REGFI_DATA_TYPE_int(pyREGFI_DATA_TYPE *self) {
    Py_INCREF(self->value);
    return self->value;
};

static PyNumberMethods REGFI_DATA_TYPE_as_number = {
        (binaryfunc)    0,       /*nb_add*/
        (binaryfunc)    0,       /*nb_subtract*/
        (binaryfunc)    0,       /*nb_multiply*/
                        0,       /*nb_divide*/
                        0,       /*nb_remainder*/
                        0,       /*nb_divmod*/
                        0,       /*nb_power*/
        (unaryfunc)     0,       /*nb_negative*/
        (unaryfunc)     0,       /*tp_positive*/
        (unaryfunc)     0,       /*tp_absolute*/
        (inquiry)       0,   /*tp_nonzero*/
        (unaryfunc)     0,       /*nb_invert*/
                        0,       /*nb_lshift*/
        (binaryfunc)    0,       /*nb_rshift*/
                        0,       /*nb_and*/
                        0,       /*nb_xor*/
                        0,       /*nb_or*/
                        0,       /*nb_coerce*/
         (unaryfunc)    REGFI_DATA_TYPE_int,       /*nb_int*/
                        0,       /*nb_long*/
                        0,       /*nb_float*/
                        0,       /*nb_oct*/
                        0,       /*nb_hex*/
        0,                              /* nb_inplace_add */
        0,                              /* nb_inplace_subtract */
        0,                              /* nb_inplace_multiply */
        0,                              /* nb_inplace_divide */
        0,                              /* nb_inplace_remainder */
        0,                              /* nb_inplace_power */
        0,                              /* nb_inplace_lshift */
        0,                              /* nb_inplace_rshift */
        0,                              /* nb_inplace_and */
        0,                              /* nb_inplace_xor */
        0,                              /* nb_inplace_or */
        0,                              /* nb_floor_divide */
        0,                              /* nb_true_divide */
        0,                              /* nb_inplace_floor_divide */
        0,                              /* nb_inplace_true_divide */
        0,                              /* nb_index */
};

static PyTypeObject REGFI_DATA_TYPE_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                         /* ob_size */
    "pyregfi.REGFI_DATA_TYPE",               /* tp_name */
    sizeof(pyREGFI_DATA_TYPE),            /* tp_basicsize */
    0,                         /* tp_itemsize */
    (destructor)REGFI_DATA_TYPE_dealloc,/* tp_dealloc */
    0,                         /* tp_print */
    0,                         /* tp_getattr */
    0,                         /* tp_setattr */
    0,                         /* tp_compare */
    0,                         /* tp_repr */
    &REGFI_DATA_TYPE_as_number,      /* tp_as_number */
    0,                         /* tp_as_sequence */
    0,                         /* tp_as_mapping */
    0,                         /* tp_hash */
    0,                         /* tp_call */
    (reprfunc)pyREGFI_DATA_TYPE___str__,      /* tp_str */
    (getattrofunc)0,                         /* tp_getattro */
    0,                         /* tp_setattro */
    0,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,        /* tp_flags */
    "REGFI_DATA_TYPE: ",     /* tp_doc */
    0,	                       /* tp_traverse */
    0,                         /* tp_clear */
    0,                         /* tp_richcompare */
    0,                         /* tp_weaklistoffset */
    (getiterfunc)0,              /* tp_iter */
    (iternextfunc)0,/* tp_iternext */
    REGFI_DATA_TYPE_methods,         /* tp_methods */
    0,                         /* tp_members */
    0,                         /* tp_getset */
    0,                         /* tp_base */
    0,                         /* tp_dict */
    0,                         /* tp_descr_get */
    0,                         /* tp_descr_set */
    0,                         /* tp_dictoffset */
    (initproc)pyREGFI_DATA_TYPE_init,      /* tp_init */
    0,                         /* tp_alloc */
    0,                         /* tp_new */
};
static PyMethodDef ValueIterator_methods[] = {
     {NULL}  /* Sentinel */
};
static void
ValueIterator_dealloc(pyValueIterator *self) {

    if(self->base) {
        //printf("Unlinking %s@%p\n", NAMEOF(self->base), self->base);
        talloc_free(self->ctx);
        self->base=NULL;
    };

 PyObject_Del(self);
};


static int pyValueIterator_init(pyValueIterator *self, PyObject *args, PyObject *kwds)
{
Gen_wrapper *key __attribute__((unused)) = NULL;
 KeyIterator __attribute__((unused)) call_key;
static char *kwlist[] = {"key", NULL};

if(!PyArg_ParseTupleAndKeywords(args, kwds, "O|", kwlist, &key))
 goto error;


if(!key || (PyObject *)key==Py_None) {
   call_key = NULL;
} else if(!type_check((PyObject *)key,&KeyIterator_Type)) {
     PyErr_Format(PyExc_RuntimeError, "key must be derived from type KeyIterator");
     goto error;
} else {
   call_key = key->base;
};

self->ctx = talloc_strdup(NULL, "ValueIterator");
 ClearError();
Py_BEGIN_ALLOW_THREADS
self->base = CONSTRUCT(ValueIterator, ValueIterator, Con, self->ctx, call_key);
Py_END_ALLOW_THREADS

       if(!CheckError(EZero)) {
         char *buffer;
         PyObject *exception = resolve_exception(&buffer);

         PyErr_Format(exception,
                    "%s", buffer);
         ClearError();
         goto error;
  } else if(!self->base) {
    PyErr_Format(PyExc_IOError, "Unable to construct class ValueIterator");
    goto error;
  };
  return 0;
error:
    return -1;
};


static PyObject *pyValueIterator_getattr(pyValueIterator *self, PyObject *pyname) {
  char *name;
  // Try to hand it off to the python native handler first
  PyObject *result = PyObject_GenericGetAttr((PyObject*)self, pyname);

  if(result) return result;

  PyErr_Clear();
  // No - nothing interesting was found by python
  name = PyString_AsString(pyname);

  if(!self->base) return PyErr_Format(PyExc_RuntimeError, "Wrapped object (ValueIterator.pyValueIterator_getattr) no longer valid");
  if(!name) return NULL;
  if(!strcmp(name, "__members__")) {
     PyObject *result = PyList_New(0);
     PyObject *tmp;
     PyMethodDef *i;

     if(!result) goto error;


    for(i=ValueIterator_methods; i->ml_name; i++) {
     tmp = PyString_FromString(i->ml_name);
    PyList_Append(result, tmp); Py_DECREF(tmp);
    }; 
     return result; 
   }


  return PyObject_GenericGetAttr((PyObject *)self, pyname);
error:
return NULL;
}


/********************************************************
Autogenerated wrapper for function:
void ValueIterator.__iter__();
********************************************************/
static PyObject *pyValueIterator___iter__(pyValueIterator *self){
          ((ValueIterator)self->base)->__iter__((ValueIterator)self->base);
          return PyObject_SelfIter((PyObject *)self);
};

/********************************************************
Autogenerated wrapper for function:
RawData ValueIterator.iternext();
********************************************************/
static PyObject *pyValueIterator_iternext(pyValueIterator *self){
       PyObject *returned_result, *py_result;
Gen_wrapper *func_return __attribute__((unused)) = NULL;
// Make sure that we have something valid to wrap
if(!self->base) return PyErr_Format(PyExc_RuntimeError, "ValueIterator object no longer valid");
// Precall preparations
// Check the function is implemented
  {  void *method = ((ValueIterator)self->base)->iternext;
     if(!method || (void *)unimplemented == (void *)method) {
         PyErr_Format(PyExc_RuntimeError, "ValueIterator.iternext is not implemented");
         goto error;
     };
  };

// Make the call
 ClearError();{
       Object returned_object;

       ClearError();

       Py_BEGIN_ALLOW_THREADS
       returned_object = (Object)((ValueIterator)self->base)->iternext(((ValueIterator)self->base));
       Py_END_ALLOW_THREADS

       CHECK_ERROR;
if(returned_object == NULL) {
     func_return = NULL; 
       } else {
         //printf("%s: Wrapping %s@%p\n", __FUNCTION__, NAMEOF(returned_object), returned_object);
         func_return = new_class_wrapper(returned_object);
         if(!func_return) goto error;
       };
    }

// Postcall preparations

// prepare results
py_result = (PyObject *)func_return;
returned_result = py_result;
return returned_result;

// error conditions:
error:
    return NULL;

};


static int
ValueIterator_nonzero(pyValueIterator *v)
{
        return v->base != 0;
};

static PyNumberMethods ValueIterator_as_number = {
        (binaryfunc)    0,       /*nb_add*/
        (binaryfunc)    0,       /*nb_subtract*/
        (binaryfunc)    0,       /*nb_multiply*/
                        0,       /*nb_divide*/
                        0,       /*nb_remainder*/
                        0,       /*nb_divmod*/
                        0,       /*nb_power*/
        (unaryfunc)     0,       /*nb_negative*/
        (unaryfunc)     0,       /*tp_positive*/
        (unaryfunc)     0,       /*tp_absolute*/
        (inquiry)       ValueIterator_nonzero,   /*tp_nonzero*/
        (unaryfunc)     0,       /*nb_invert*/
                        0,       /*nb_lshift*/
        (binaryfunc)    0,       /*nb_rshift*/
                        0,       /*nb_and*/
                        0,       /*nb_xor*/
                        0,       /*nb_or*/
                        0,       /*nb_coerce*/
         (unaryfunc)    0,       /*nb_int*/
                        0,       /*nb_long*/
                        0,       /*nb_float*/
                        0,       /*nb_oct*/
                        0,       /*nb_hex*/
        0,                              /* nb_inplace_add */
        0,                              /* nb_inplace_subtract */
        0,                              /* nb_inplace_multiply */
        0,                              /* nb_inplace_divide */
        0,                              /* nb_inplace_remainder */
        0,                              /* nb_inplace_power */
        0,                              /* nb_inplace_lshift */
        0,                              /* nb_inplace_rshift */
        0,                              /* nb_inplace_and */
        0,                              /* nb_inplace_xor */
        0,                              /* nb_inplace_or */
        0,                              /* nb_floor_divide */
        0,                              /* nb_true_divide */
        0,                              /* nb_inplace_floor_divide */
        0,                              /* nb_inplace_true_divide */
        0,                              /* nb_index */
};

static PyTypeObject ValueIterator_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                         /* ob_size */
    "pyregfi.ValueIterator",               /* tp_name */
    sizeof(pyValueIterator),            /* tp_basicsize */
    0,                         /* tp_itemsize */
    (destructor)ValueIterator_dealloc,/* tp_dealloc */
    0,                         /* tp_print */
    0,                         /* tp_getattr */
    0,                         /* tp_setattr */
    0,                         /* tp_compare */
    0,                         /* tp_repr */
    &ValueIterator_as_number,      /* tp_as_number */
    0,                         /* tp_as_sequence */
    0,                         /* tp_as_mapping */
    0,                         /* tp_hash */
    0,                         /* tp_call */
    (reprfunc)0,      /* tp_str */
    (getattrofunc)pyValueIterator_getattr,                         /* tp_getattro */
    0,                         /* tp_setattro */
    0,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,        /* tp_flags */
    "ValueIterator:  This is an iterator for reading values from the registry ",     /* tp_doc */
    0,	                       /* tp_traverse */
    0,                         /* tp_clear */
    0,                         /* tp_richcompare */
    0,                         /* tp_weaklistoffset */
    (getiterfunc)pyValueIterator___iter__,              /* tp_iter */
    (iternextfunc)pyValueIterator_iternext,/* tp_iternext */
    ValueIterator_methods,         /* tp_methods */
    0,                         /* tp_members */
    0,                         /* tp_getset */
    0,                         /* tp_base */
    0,                         /* tp_dict */
    0,                         /* tp_descr_get */
    0,                         /* tp_descr_set */
    0,                         /* tp_dictoffset */
    (initproc)pyValueIterator_init,      /* tp_init */
    0,                         /* tp_alloc */
    0,                         /* tp_new */
};
static PyMethodDef REGFI_VK_REC_methods[] = {
     {NULL}  /* Sentinel */
};
static void
REGFI_VK_REC_dealloc(pyREGFI_VK_REC *self) {
   talloc_free(self->ctx);
};

static int pyREGFI_VK_REC_init(pyREGFI_VK_REC *self, PyObject *args, PyObject *kwds) {

self->ctx = talloc_strdup(NULL, "REGFI_VK_REC");
self->base = talloc(self->ctx, REGFI_VK_REC);
  return 0;
};


static PyObject *pyREGFI_VK_REC_getattr(pyREGFI_VK_REC *self, PyObject *pyname) {
  char *name;
  // Try to hand it off to the python native handler first
  PyObject *result = PyObject_GenericGetAttr((PyObject*)self, pyname);

  if(result) return result;

  PyErr_Clear();
  // No - nothing interesting was found by python
  name = PyString_AsString(pyname);

  if(!self->base) return PyErr_Format(PyExc_RuntimeError, "Wrapped object (REGFI_VK_REC.pyREGFI_VK_REC_getattr) no longer valid");
  if(!name) return NULL;
  if(!strcmp(name, "__members__")) {
     PyObject *result = PyList_New(0);
     PyObject *tmp;
     PyMethodDef *i;

     if(!result) goto error;
 tmp = PyString_FromString("offset");
    PyList_Append(result, tmp); Py_DECREF(tmp);
 tmp = PyString_FromString("cell_size");
    PyList_Append(result, tmp); Py_DECREF(tmp);
 tmp = PyString_FromString("data");
    PyList_Append(result, tmp); Py_DECREF(tmp);
 tmp = PyString_FromString("valuename");
    PyList_Append(result, tmp); Py_DECREF(tmp);
 tmp = PyString_FromString("name_length");
    PyList_Append(result, tmp); Py_DECREF(tmp);
 tmp = PyString_FromString("hbin_off");
    PyList_Append(result, tmp); Py_DECREF(tmp);
 tmp = PyString_FromString("data_size");
    PyList_Append(result, tmp); Py_DECREF(tmp);
 tmp = PyString_FromString("data_off");
    PyList_Append(result, tmp); Py_DECREF(tmp);
 tmp = PyString_FromString("type");
    PyList_Append(result, tmp); Py_DECREF(tmp);
 tmp = PyString_FromString("flags");
    PyList_Append(result, tmp); Py_DECREF(tmp);
 tmp = PyString_FromString("unknown1");
    PyList_Append(result, tmp); Py_DECREF(tmp);


    for(i=REGFI_VK_REC_methods; i->ml_name; i++) {
     tmp = PyString_FromString(i->ml_name);
    PyList_Append(result, tmp); Py_DECREF(tmp);
    }; 
     return result; 
   }

if(!strcmp(name, "offset")) {
    PyObject *py_result;
    unsigned int  __attribute__((unused)) offset;


    Py_BEGIN_ALLOW_THREADS
offset = (self->base->offset);
Py_END_ALLOW_THREADS

    PyErr_Clear();
py_result = PyLong_FromLong(offset);

    return py_result;
};
if(!strcmp(name, "cell_size")) {
    PyObject *py_result;
    unsigned int  __attribute__((unused)) cell_size;


    Py_BEGIN_ALLOW_THREADS
cell_size = (self->base->cell_size);
Py_END_ALLOW_THREADS

    PyErr_Clear();
py_result = PyLong_FromLong(cell_size);

    return py_result;
};
if(!strcmp(name, "data")) {
    PyObject *py_result;
    Gen_wrapper *data = NULL;

    
PyErr_Clear();
data = (Gen_wrapper *)PyObject_New(pyREGFI_DATA, &REGFI_DATA_Type);
data->ctx = talloc_size(NULL, 1);
data->base = (self->base->data);

// A NULL object gets translated to a None
 if(!data->base) {
   Py_DECREF(data);
   Py_INCREF(Py_None);
   data = (Gen_wrapper *)Py_None;
 } else {
// Not taking references to foreign memory
}

    py_result = (PyObject *)data;

    return py_result;
};
if(!strcmp(name, "valuename")) {
    PyObject *py_result;
    char * __attribute__((unused)) valuename;


    Py_BEGIN_ALLOW_THREADS
valuename = (self->base->valuename);
Py_END_ALLOW_THREADS

    PyErr_Clear();
   if(!valuename) { PyErr_Format(PyExc_RuntimeError, "valuename is NULL"); goto error; };
   py_result = PyString_FromStringAndSize((char *)valuename, strlen(valuename));
if(!py_result) goto error;

    return py_result;
};
if(!strcmp(name, "name_length")) {
    PyObject *py_result;
    uint64_t __attribute__((unused)) name_length;


    Py_BEGIN_ALLOW_THREADS
name_length = (self->base->name_length);
Py_END_ALLOW_THREADS

    PyErr_Clear();
py_result = PyLong_FromLongLong(name_length);

    return py_result;
};
if(!strcmp(name, "hbin_off")) {
    PyObject *py_result;
    unsigned int  __attribute__((unused)) hbin_off;


    Py_BEGIN_ALLOW_THREADS
hbin_off = (self->base->hbin_off);
Py_END_ALLOW_THREADS

    PyErr_Clear();
py_result = PyLong_FromLong(hbin_off);

    return py_result;
};
if(!strcmp(name, "data_size")) {
    PyObject *py_result;
    unsigned int  __attribute__((unused)) data_size;


    Py_BEGIN_ALLOW_THREADS
data_size = (self->base->data_size);
Py_END_ALLOW_THREADS

    PyErr_Clear();
py_result = PyLong_FromLong(data_size);

    return py_result;
};
if(!strcmp(name, "data_off")) {
    PyObject *py_result;
    unsigned int  __attribute__((unused)) data_off;


    Py_BEGIN_ALLOW_THREADS
data_off = (self->base->data_off);
Py_END_ALLOW_THREADS

    PyErr_Clear();
py_result = PyLong_FromLong(data_off);

    return py_result;
};
if(!strcmp(name, "type")) {
    PyObject *py_result;
    REGFI_DATA_TYPE __attribute__((unused)) type;


    Py_BEGIN_ALLOW_THREADS
type = (self->base->type);
Py_END_ALLOW_THREADS

    PyErr_Clear();
py_result = PyObject_CallMethod(g_module, "REGFI_DATA_TYPE", "K", (uint64_t)type);

    return py_result;
};
if(!strcmp(name, "flags")) {
    PyObject *py_result;
    uint64_t __attribute__((unused)) flags;


    Py_BEGIN_ALLOW_THREADS
flags = (self->base->flags);
Py_END_ALLOW_THREADS

    PyErr_Clear();
py_result = PyLong_FromLongLong(flags);

    return py_result;
};
if(!strcmp(name, "unknown1")) {
    PyObject *py_result;
    uint64_t __attribute__((unused)) unknown1;


    Py_BEGIN_ALLOW_THREADS
unknown1 = (self->base->unknown1);
Py_END_ALLOW_THREADS

    PyErr_Clear();
py_result = PyLong_FromLongLong(unknown1);

    return py_result;
};

  return PyObject_GenericGetAttr((PyObject *)self, pyname);
error:
return NULL;
}


static int
REGFI_VK_REC_nonzero(pyREGFI_VK_REC *v)
{
        return v->base != 0;
};

static PyNumberMethods REGFI_VK_REC_as_number = {
        (binaryfunc)    0,       /*nb_add*/
        (binaryfunc)    0,       /*nb_subtract*/
        (binaryfunc)    0,       /*nb_multiply*/
                        0,       /*nb_divide*/
                        0,       /*nb_remainder*/
                        0,       /*nb_divmod*/
                        0,       /*nb_power*/
        (unaryfunc)     0,       /*nb_negative*/
        (unaryfunc)     0,       /*tp_positive*/
        (unaryfunc)     0,       /*tp_absolute*/
        (inquiry)       REGFI_VK_REC_nonzero,   /*tp_nonzero*/
        (unaryfunc)     0,       /*nb_invert*/
                        0,       /*nb_lshift*/
        (binaryfunc)    0,       /*nb_rshift*/
                        0,       /*nb_and*/
                        0,       /*nb_xor*/
                        0,       /*nb_or*/
                        0,       /*nb_coerce*/
         (unaryfunc)    0,       /*nb_int*/
                        0,       /*nb_long*/
                        0,       /*nb_float*/
                        0,       /*nb_oct*/
                        0,       /*nb_hex*/
        0,                              /* nb_inplace_add */
        0,                              /* nb_inplace_subtract */
        0,                              /* nb_inplace_multiply */
        0,                              /* nb_inplace_divide */
        0,                              /* nb_inplace_remainder */
        0,                              /* nb_inplace_power */
        0,                              /* nb_inplace_lshift */
        0,                              /* nb_inplace_rshift */
        0,                              /* nb_inplace_and */
        0,                              /* nb_inplace_xor */
        0,                              /* nb_inplace_or */
        0,                              /* nb_floor_divide */
        0,                              /* nb_true_divide */
        0,                              /* nb_inplace_floor_divide */
        0,                              /* nb_inplace_true_divide */
        0,                              /* nb_index */
};

static PyTypeObject REGFI_VK_REC_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                         /* ob_size */
    "pyregfi.REGFI_VK_REC",               /* tp_name */
    sizeof(pyREGFI_VK_REC),            /* tp_basicsize */
    0,                         /* tp_itemsize */
    (destructor)REGFI_VK_REC_dealloc,/* tp_dealloc */
    0,                         /* tp_print */
    0,                         /* tp_getattr */
    0,                         /* tp_setattr */
    0,                         /* tp_compare */
    0,                         /* tp_repr */
    &REGFI_VK_REC_as_number,      /* tp_as_number */
    0,                         /* tp_as_sequence */
    0,                         /* tp_as_mapping */
    0,                         /* tp_hash */
    0,                         /* tp_call */
    (reprfunc)0,      /* tp_str */
    (getattrofunc)pyREGFI_VK_REC_getattr,                         /* tp_getattro */
    0,                         /* tp_setattro */
    0,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,        /* tp_flags */
    "REGFI_VK_REC:  Value structure\n * @ingroup regfiBase\n ",     /* tp_doc */
    0,	                       /* tp_traverse */
    0,                         /* tp_clear */
    0,                         /* tp_richcompare */
    0,                         /* tp_weaklistoffset */
    (getiterfunc)0,              /* tp_iter */
    (iternextfunc)0,/* tp_iternext */
    REGFI_VK_REC_methods,         /* tp_methods */
    0,                         /* tp_members */
    0,                         /* tp_getset */
    0,                         /* tp_base */
    0,                         /* tp_dict */
    0,                         /* tp_descr_get */
    0,                         /* tp_descr_set */
    0,                         /* tp_dictoffset */
    (initproc)pyREGFI_VK_REC_init,      /* tp_init */
    0,                         /* tp_alloc */
    0,                         /* tp_new */
};
static PyMethodDef DWORDData_methods[] = {
     {"get_value",(PyCFunction)pyDWORDData_get_value, METH_VARARGS|METH_KEYWORDS, "uint64_t DWORDData.get_value();\n\n\n"},
     {NULL}  /* Sentinel */
};
static void
DWORDData_dealloc(pyDWORDData *self) {

    if(self->base) {
        //printf("Unlinking %s@%p\n", NAMEOF(self->base), self->base);
        talloc_free(self->ctx);
        self->base=NULL;
    };

 PyObject_Del(self);
};


static int pyDWORDData_init(pyDWORDData *self, PyObject *args, PyObject *kwds)
{
Gen_wrapper *data = NULL; REGFI_DATA *call_data;
Gen_wrapper *record = NULL; REGFI_VK_REC *call_record;
static char *kwlist[] = {"data","record", NULL};

if(!PyArg_ParseTupleAndKeywords(args, kwds, "OO|", kwlist, &data,&record))
 goto error;


if(!data || (PyObject *)data==Py_None) {
   call_data = NULL;
} else if(!type_check((PyObject *)data,&REGFI_DATA_Type)) {
     PyErr_Format(PyExc_RuntimeError, "data must be derived from type REGFI_DATA");
     goto error;
} else {
   call_data = data->base;
};

if(!record || (PyObject *)record==Py_None) {
   call_record = NULL;
} else if(!type_check((PyObject *)record,&REGFI_VK_REC_Type)) {
     PyErr_Format(PyExc_RuntimeError, "record must be derived from type REGFI_VK_REC");
     goto error;
} else {
   call_record = record->base;
};

self->ctx = talloc_strdup(NULL, "DWORDData");
 ClearError();
Py_BEGIN_ALLOW_THREADS
self->base = CONSTRUCT(DWORDData, RawData, Con, self->ctx, call_data, call_record);
Py_END_ALLOW_THREADS

       if(!CheckError(EZero)) {
         char *buffer;
         PyObject *exception = resolve_exception(&buffer);

         PyErr_Format(exception,
                    "%s", buffer);
         ClearError();
         goto error;
  } else if(!self->base) {
    PyErr_Format(PyExc_IOError, "Unable to construct class DWORDData");
    goto error;
  };
  return 0;
error:
    return -1;
};


static PyObject *pyDWORDData_getattr(pyDWORDData *self, PyObject *pyname) {
  char *name;
  // Try to hand it off to the python native handler first
  PyObject *result = PyObject_GenericGetAttr((PyObject*)self, pyname);

  if(result) return result;

  PyErr_Clear();
  // No - nothing interesting was found by python
  name = PyString_AsString(pyname);

  if(!self->base) return PyErr_Format(PyExc_RuntimeError, "Wrapped object (DWORDData.pyDWORDData_getattr) no longer valid");
  if(!name) return NULL;
  if(!strcmp(name, "__members__")) {
     PyObject *result = PyList_New(0);
     PyObject *tmp;
     PyMethodDef *i;

     if(!result) goto error;
 tmp = PyString_FromString("data");
    PyList_Append(result, tmp); Py_DECREF(tmp);
 tmp = PyString_FromString("rec");
    PyList_Append(result, tmp); Py_DECREF(tmp);


    for(i=DWORDData_methods; i->ml_name; i++) {
     tmp = PyString_FromString(i->ml_name);
    PyList_Append(result, tmp); Py_DECREF(tmp);
    }; 
     return result; 
   }

if(!strcmp(name, "data")) {
    PyObject *py_result;
    Gen_wrapper *data = NULL;

    
PyErr_Clear();
data = (Gen_wrapper *)PyObject_New(pyREGFI_DATA, &REGFI_DATA_Type);
data->ctx = talloc_size(NULL, 1);
data->base = (((RawData)self->base)->data);

// A NULL object gets translated to a None
 if(!data->base) {
   Py_DECREF(data);
   Py_INCREF(Py_None);
   data = (Gen_wrapper *)Py_None;
 } else {
talloc_reference(data->ctx, data->base);
}

    py_result = (PyObject *)data;

    return py_result;
};
if(!strcmp(name, "rec")) {
    PyObject *py_result;
    Gen_wrapper *rec = NULL;

    
PyErr_Clear();
rec = (Gen_wrapper *)PyObject_New(pyREGFI_VK_REC, &REGFI_VK_REC_Type);
rec->ctx = talloc_size(NULL, 1);
rec->base = (((RawData)self->base)->rec);

// A NULL object gets translated to a None
 if(!rec->base) {
   Py_DECREF(rec);
   Py_INCREF(Py_None);
   rec = (Gen_wrapper *)Py_None;
 } else {
talloc_reference(rec->ctx, rec->base);
}

    py_result = (PyObject *)rec;

    return py_result;
};

  return PyObject_GenericGetAttr((PyObject *)self, pyname);
error:
return NULL;
}


/********************************************************
Autogenerated wrapper for function:
uint64_t DWORDData.get_value();
********************************************************/
static PyObject *pyDWORDData_get_value(pyDWORDData *self, PyObject *args, PyObject *kwds) {
       PyObject *returned_result, *py_result;
uint64_t __attribute__((unused)) func_return;
// Make sure that we have something valid to wrap
if(!self->base) return PyErr_Format(PyExc_RuntimeError, "DWORDData object no longer valid");
// Precall preparations
// Check the function is implemented
  {  void *method = ((DWORDData)self->base)->get_value;
     if(!method || (void *)unimplemented == (void *)method) {
         PyErr_Format(PyExc_RuntimeError, "DWORDData.get_value is not implemented");
         goto error;
     };
  };

// Make the call
 ClearError();Py_BEGIN_ALLOW_THREADS
func_return = ((DWORDData)self->base)->get_value(((DWORDData)self->base));
Py_END_ALLOW_THREADS

// Postcall preparations

// prepare results
PyErr_Clear();
py_result = PyLong_FromLongLong(func_return);
returned_result = py_result;
return returned_result;

// error conditions:
error:
    return NULL;

};


static int
DWORDData_nonzero(pyDWORDData *v)
{
        return v->base != 0;
};

static PyNumberMethods DWORDData_as_number = {
        (binaryfunc)    0,       /*nb_add*/
        (binaryfunc)    0,       /*nb_subtract*/
        (binaryfunc)    0,       /*nb_multiply*/
                        0,       /*nb_divide*/
                        0,       /*nb_remainder*/
                        0,       /*nb_divmod*/
                        0,       /*nb_power*/
        (unaryfunc)     0,       /*nb_negative*/
        (unaryfunc)     0,       /*tp_positive*/
        (unaryfunc)     0,       /*tp_absolute*/
        (inquiry)       DWORDData_nonzero,   /*tp_nonzero*/
        (unaryfunc)     0,       /*nb_invert*/
                        0,       /*nb_lshift*/
        (binaryfunc)    0,       /*nb_rshift*/
                        0,       /*nb_and*/
                        0,       /*nb_xor*/
                        0,       /*nb_or*/
                        0,       /*nb_coerce*/
         (unaryfunc)    0,       /*nb_int*/
                        0,       /*nb_long*/
                        0,       /*nb_float*/
                        0,       /*nb_oct*/
                        0,       /*nb_hex*/
        0,                              /* nb_inplace_add */
        0,                              /* nb_inplace_subtract */
        0,                              /* nb_inplace_multiply */
        0,                              /* nb_inplace_divide */
        0,                              /* nb_inplace_remainder */
        0,                              /* nb_inplace_power */
        0,                              /* nb_inplace_lshift */
        0,                              /* nb_inplace_rshift */
        0,                              /* nb_inplace_and */
        0,                              /* nb_inplace_xor */
        0,                              /* nb_inplace_or */
        0,                              /* nb_floor_divide */
        0,                              /* nb_true_divide */
        0,                              /* nb_inplace_floor_divide */
        0,                              /* nb_inplace_true_divide */
        0,                              /* nb_index */
};

static PyTypeObject DWORDData_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                         /* ob_size */
    "pyregfi.DWORDData",               /* tp_name */
    sizeof(pyDWORDData),            /* tp_basicsize */
    0,                         /* tp_itemsize */
    (destructor)DWORDData_dealloc,/* tp_dealloc */
    0,                         /* tp_print */
    0,                         /* tp_getattr */
    0,                         /* tp_setattr */
    0,                         /* tp_compare */
    0,                         /* tp_repr */
    &DWORDData_as_number,      /* tp_as_number */
    0,                         /* tp_as_sequence */
    0,                         /* tp_as_mapping */
    0,                         /* tp_hash */
    0,                         /* tp_call */
    (reprfunc)0,      /* tp_str */
    (getattrofunc)pyDWORDData_getattr,                         /* tp_getattro */
    0,                         /* tp_setattro */
    0,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,        /* tp_flags */
    "DWORDData: ",     /* tp_doc */
    0,	                       /* tp_traverse */
    0,                         /* tp_clear */
    0,                         /* tp_richcompare */
    0,                         /* tp_weaklistoffset */
    (getiterfunc)0,              /* tp_iter */
    (iternextfunc)0,/* tp_iternext */
    DWORDData_methods,         /* tp_methods */
    0,                         /* tp_members */
    0,                         /* tp_getset */
    0,                         /* tp_base */
    0,                         /* tp_dict */
    0,                         /* tp_descr_get */
    0,                         /* tp_descr_set */
    0,                         /* tp_dictoffset */
    (initproc)pyDWORDData_init,      /* tp_init */
    0,                         /* tp_alloc */
    0,                         /* tp_new */
};

static PyMethodDef pyregfi_methods[] = {
     {NULL}  /* Sentinel */
};

PyMODINIT_FUNC initpyregfi(void) {
   /* Make sure threads are enabled */
   PyEval_InitThreads();

   /* create module */
   PyObject *m = Py_InitModule3("pyregfi", pyregfi_methods,
                                   "pyregfi module.");
   PyObject *d = PyModule_GetDict(m);
   PyObject *tmp;

   g_module = m;

 REGFI_DATA_Type.tp_new = PyType_GenericNew;
 if (PyType_Ready(&REGFI_DATA_Type) < 0)
     return;

 Py_INCREF((PyObject *)&REGFI_DATA_Type);
 PyModule_AddObject(m, "REGFI_DATA", (PyObject *)&REGFI_DATA_Type);

 REGFI_NK_REC_Type.tp_new = PyType_GenericNew;
 if (PyType_Ready(&REGFI_NK_REC_Type) < 0)
     return;

 Py_INCREF((PyObject *)&REGFI_NK_REC_Type);
 PyModule_AddObject(m, "REGFI_NK_REC", (PyObject *)&REGFI_NK_REC_Type);

 Object_Type.tp_new = PyType_GenericNew;
 if (PyType_Ready(&Object_Type) < 0)
     return;

 Py_INCREF((PyObject *)&Object_Type);
 PyModule_AddObject(m, "Object", (PyObject *)&Object_Type);
 KeyIterator_Type.tp_base = &Object_Type;
 KeyIterator_Type.tp_new = PyType_GenericNew;
 if (PyType_Ready(&KeyIterator_Type) < 0)
     return;

 Py_INCREF((PyObject *)&KeyIterator_Type);
 PyModule_AddObject(m, "KeyIterator", (PyObject *)&KeyIterator_Type);
 RegistryFile_Type.tp_base = &Object_Type;
 RegistryFile_Type.tp_new = PyType_GenericNew;
 if (PyType_Ready(&RegistryFile_Type) < 0)
     return;

 Py_INCREF((PyObject *)&RegistryFile_Type);
 PyModule_AddObject(m, "RegistryFile", (PyObject *)&RegistryFile_Type);
 RawData_Type.tp_base = &Object_Type;
 RawData_Type.tp_new = PyType_GenericNew;
 if (PyType_Ready(&RawData_Type) < 0)
     return;

 Py_INCREF((PyObject *)&RawData_Type);
 PyModule_AddObject(m, "RawData", (PyObject *)&RawData_Type);
 DataString_Type.tp_base = &RawData_Type;
 DataString_Type.tp_new = PyType_GenericNew;
 if (PyType_Ready(&DataString_Type) < 0)
     return;

 Py_INCREF((PyObject *)&DataString_Type);
 PyModule_AddObject(m, "DataString", (PyObject *)&DataString_Type);

 REGFI_ENCODING_Type.tp_new = PyType_GenericNew;
 if (PyType_Ready(&REGFI_ENCODING_Type) < 0)
     return;

 Py_INCREF((PyObject *)&REGFI_ENCODING_Type);
 PyModule_AddObject(m, "REGFI_ENCODING", (PyObject *)&REGFI_ENCODING_Type);

 REGFI_DATA_TYPE_Type.tp_new = PyType_GenericNew;
 if (PyType_Ready(&REGFI_DATA_TYPE_Type) < 0)
     return;

 Py_INCREF((PyObject *)&REGFI_DATA_TYPE_Type);
 PyModule_AddObject(m, "REGFI_DATA_TYPE", (PyObject *)&REGFI_DATA_TYPE_Type);
 ValueIterator_Type.tp_base = &Object_Type;
 ValueIterator_Type.tp_new = PyType_GenericNew;
 if (PyType_Ready(&ValueIterator_Type) < 0)
     return;

 Py_INCREF((PyObject *)&ValueIterator_Type);
 PyModule_AddObject(m, "ValueIterator", (PyObject *)&ValueIterator_Type);

 REGFI_VK_REC_Type.tp_new = PyType_GenericNew;
 if (PyType_Ready(&REGFI_VK_REC_Type) < 0)
     return;

 Py_INCREF((PyObject *)&REGFI_VK_REC_Type);
 PyModule_AddObject(m, "REGFI_VK_REC", (PyObject *)&REGFI_VK_REC_Type);
 DWORDData_Type.tp_base = &RawData_Type;
 DWORDData_Type.tp_new = PyType_GenericNew;
 if (PyType_Ready(&DWORDData_Type) < 0)
     return;

 Py_INCREF((PyObject *)&DWORDData_Type);
 PyModule_AddObject(m, "DWORDData", (PyObject *)&DWORDData_Type);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REG_SZ); 

 PyDict_SetItemString(d, "REG_SZ", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REG_DWORD_LE); 

 PyDict_SetItemString(d, "REG_DWORD_LE", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REG_DWORD); 

 PyDict_SetItemString(d, "REG_DWORD", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REGFI_REGF_RESERVED1_SIZE); 

 PyDict_SetItemString(d, "REGFI_REGF_RESERVED1_SIZE", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REGFI_BIG_DATA_MIN_LENGTH); 

 PyDict_SetItemString(d, "REGFI_BIG_DATA_MIN_LENGTH", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REG_BINARY); 

 PyDict_SetItemString(d, "REG_BINARY", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REGFI_NK_FLAG_VOLATILE); 

 PyDict_SetItemString(d, "REGFI_NK_FLAG_VOLATILE", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REGFI_NK_FLAG_HIVE_LINK); 

 PyDict_SetItemString(d, "REGFI_NK_FLAG_HIVE_LINK", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REG_QWORD); 

 PyDict_SetItemString(d, "REG_QWORD", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REGFI_VK_MIN_LENGTH); 

 PyDict_SetItemString(d, "REGFI_VK_MIN_LENGTH", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REG_DWORD_BE); 

 PyDict_SetItemString(d, "REG_DWORD_BE", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REGFI_NUM_ENCODINGS); 

 PyDict_SetItemString(d, "REGFI_NUM_ENCODINGS", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REGFI_VK_DATA_IN_OFFSET); 

 PyDict_SetItemString(d, "REGFI_VK_DATA_IN_OFFSET", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REGFI_REGF_MAGIC_SIZE); 

 PyDict_SetItemString(d, "REGFI_REGF_MAGIC_SIZE", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REGFI_ENCODING_DEFAULT); 

 PyDict_SetItemString(d, "REGFI_ENCODING_DEFAULT", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REGFI_REGF_RESERVED2_SIZE); 

 PyDict_SetItemString(d, "REGFI_REGF_RESERVED2_SIZE", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REGFI_MTIME_MAX_HIGH); 

 PyDict_SetItemString(d, "REGFI_MTIME_MAX_HIGH", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)TIME_FIXUP_CONSTANT); 

 PyDict_SetItemString(d, "TIME_FIXUP_CONSTANT", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REG_EXPAND_SZ); 

 PyDict_SetItemString(d, "REG_EXPAND_SZ", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REGFI_LOG_WARN); 

 PyDict_SetItemString(d, "REGFI_LOG_WARN", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REGFI_NK_FLAG_UNKNOWN1); 

 PyDict_SetItemString(d, "REGFI_NK_FLAG_UNKNOWN1", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REG_KEY); 

 PyDict_SetItemString(d, "REG_KEY", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REG_MULTI_SZ); 

 PyDict_SetItemString(d, "REG_MULTI_SZ", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REGFI_NK_FLAG_ASCIINAME); 

 PyDict_SetItemString(d, "REGFI_NK_FLAG_ASCIINAME", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REGFI_MTIME_MIN_HIGH); 

 PyDict_SetItemString(d, "REGFI_MTIME_MIN_HIGH", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REGFI_OFFSET_NONE); 

 PyDict_SetItemString(d, "REGFI_OFFSET_NONE", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REGFI_HBIN_MAGIC_SIZE); 

 PyDict_SetItemString(d, "REGFI_HBIN_MAGIC_SIZE", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REGFI_DEFAULT_LOG_MASK); 

 PyDict_SetItemString(d, "REGFI_DEFAULT_LOG_MASK", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REGFI_ENCODING_ASCII); 

 PyDict_SetItemString(d, "REGFI_ENCODING_ASCII", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REGFI_SUBKEY_LIST_MIN_LEN); 

 PyDict_SetItemString(d, "REGFI_SUBKEY_LIST_MIN_LEN", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REGFI_HBIN_HEADER_SIZE); 

 PyDict_SetItemString(d, "REGFI_HBIN_HEADER_SIZE", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REGFI_ENCODING_UTF16LE); 

 PyDict_SetItemString(d, "REGFI_ENCODING_UTF16LE", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REGFI_SK_MIN_LENGTH); 

 PyDict_SetItemString(d, "REGFI_SK_MIN_LENGTH", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REGFI_NK_FLAG_UNKNOWN3); 

 PyDict_SetItemString(d, "REGFI_NK_FLAG_UNKNOWN3", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REGFI_CELL_MAGIC_SIZE); 

 PyDict_SetItemString(d, "REGFI_CELL_MAGIC_SIZE", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REG_NONE); 

 PyDict_SetItemString(d, "REG_NONE", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)CHAR_BIT); 

 PyDict_SetItemString(d, "CHAR_BIT", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REGFI_NK_FLAG_ROOT); 

 PyDict_SetItemString(d, "REGFI_NK_FLAG_ROOT", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REGFI_REGF_NAME_SIZE); 

 PyDict_SetItemString(d, "REGFI_REGF_NAME_SIZE", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REGFI_VK_FLAG_ASCIINAME); 

 PyDict_SetItemString(d, "REGFI_VK_FLAG_ASCIINAME", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REGFI_LOG_ERROR); 

 PyDict_SetItemString(d, "REGFI_LOG_ERROR", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REGFI_LOG_INFO); 

 PyDict_SetItemString(d, "REGFI_LOG_INFO", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REGFI_NK_FLAG_LINK); 

 PyDict_SetItemString(d, "REGFI_NK_FLAG_LINK", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REGFI_MAX_DEPTH); 

 PyDict_SetItemString(d, "REGFI_MAX_DEPTH", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REGFI_NK_KNOWN_FLAGS); 

 PyDict_SetItemString(d, "REGFI_NK_KNOWN_FLAGS", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)TIME_T_MAX); 

 PyDict_SetItemString(d, "TIME_T_MAX", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REGFI_NK_MIN_LENGTH); 

 PyDict_SetItemString(d, "REGFI_NK_MIN_LENGTH", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REGFI_REGF_SIZE); 

 PyDict_SetItemString(d, "REGFI_REGF_SIZE", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REGFI_NK_FLAG_UNKNOWN2); 

 PyDict_SetItemString(d, "REGFI_NK_FLAG_UNKNOWN2", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REGFI_MAX_SUBKEY_DEPTH); 

 PyDict_SetItemString(d, "REGFI_MAX_SUBKEY_DEPTH", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REGFI_CACHE_SK); 

 PyDict_SetItemString(d, "REGFI_CACHE_SK", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REGFI_NK_FLAG_NO_RM); 

 PyDict_SetItemString(d, "REGFI_NK_FLAG_NO_RM", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REGFI_NK_FLAG_PREDEF_KEY); 

 PyDict_SetItemString(d, "REGFI_NK_FLAG_PREDEF_KEY", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)TIME_T_MIN); 

 PyDict_SetItemString(d, "TIME_T_MIN", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REGFI_ENCODING_UTF8); 

 PyDict_SetItemString(d, "REGFI_ENCODING_UTF8", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REG_RESOURCE_LIST); 

 PyDict_SetItemString(d, "REG_RESOURCE_LIST", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REGFI_VK_MAX_DATA_LENGTH); 

 PyDict_SetItemString(d, "REGFI_VK_MAX_DATA_LENGTH", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REG_LINK); 

 PyDict_SetItemString(d, "REG_LINK", tmp);
 Py_DECREF(tmp);
 tmp = PyLong_FromUnsignedLongLong((int64_t)REGFI_HBIN_ALLOC); 

 PyDict_SetItemString(d, "REGFI_HBIN_ALLOC", tmp);
 Py_DECREF(tmp);
pyregfi_init();
talloc_set_log_fn((void *)printf);
python_wrappers[TOTAL_CLASSES].class_ref = (Object)&__KeyIterator;
python_wrappers[TOTAL_CLASSES++].python_type = &KeyIterator_Type;
python_wrappers[TOTAL_CLASSES].class_ref = (Object)&__Object;
python_wrappers[TOTAL_CLASSES++].python_type = &Object_Type;
python_wrappers[TOTAL_CLASSES].class_ref = (Object)&__RegistryFile;
python_wrappers[TOTAL_CLASSES++].python_type = &RegistryFile_Type;
python_wrappers[TOTAL_CLASSES].class_ref = (Object)&__DataString;
python_wrappers[TOTAL_CLASSES++].python_type = &DataString_Type;
python_wrappers[TOTAL_CLASSES].class_ref = (Object)&__RawData;
python_wrappers[TOTAL_CLASSES++].python_type = &RawData_Type;

REGFI_ENCODING_Dict_lookup = PyDict_New();
REGFI_ENCODING_rev_lookup = PyDict_New();
{ PyObject *tmp, *tmp2;
 tmp = PyLong_FromLong(REGFI_ENCODING_DEFAULT);
  tmp2 = PyString_FromString("REGFI_ENCODING_DEFAULT");
  PyDict_SetItem(REGFI_ENCODING_Dict_lookup, tmp2, tmp);
  PyDict_SetItem(REGFI_ENCODING_rev_lookup, tmp, tmp2);
  Py_DECREF(tmp);
  Py_DECREF(tmp2);

 tmp = PyLong_FromLong(REGFI_ENCODING_ASCII);
  tmp2 = PyString_FromString("REGFI_ENCODING_ASCII");
  PyDict_SetItem(REGFI_ENCODING_Dict_lookup, tmp2, tmp);
  PyDict_SetItem(REGFI_ENCODING_rev_lookup, tmp, tmp2);
  Py_DECREF(tmp);
  Py_DECREF(tmp2);

 tmp = PyLong_FromLong(REGFI_ENCODING_UTF8);
  tmp2 = PyString_FromString("REGFI_ENCODING_UTF8");
  PyDict_SetItem(REGFI_ENCODING_Dict_lookup, tmp2, tmp);
  PyDict_SetItem(REGFI_ENCODING_rev_lookup, tmp, tmp2);
  Py_DECREF(tmp);
  Py_DECREF(tmp2);

 tmp = PyLong_FromLong(REGFI_ENCODING_UTF16LE);
  tmp2 = PyString_FromString("REGFI_ENCODING_UTF16LE");
  PyDict_SetItem(REGFI_ENCODING_Dict_lookup, tmp2, tmp);
  PyDict_SetItem(REGFI_ENCODING_rev_lookup, tmp, tmp2);
  Py_DECREF(tmp);
  Py_DECREF(tmp2);

 tmp = PyLong_FromLong(REGFI_NUM_ENCODINGS);
  tmp2 = PyString_FromString("REGFI_NUM_ENCODINGS");
  PyDict_SetItem(REGFI_ENCODING_Dict_lookup, tmp2, tmp);
  PyDict_SetItem(REGFI_ENCODING_rev_lookup, tmp, tmp2);
  Py_DECREF(tmp);
  Py_DECREF(tmp2);

};

REGFI_DATA_TYPE_Dict_lookup = PyDict_New();
REGFI_DATA_TYPE_rev_lookup = PyDict_New();
{ PyObject *tmp, *tmp2;
 tmp = PyLong_FromLong(REG_NONE);
  tmp2 = PyString_FromString("REG_NONE");
  PyDict_SetItem(REGFI_DATA_TYPE_Dict_lookup, tmp2, tmp);
  PyDict_SetItem(REGFI_DATA_TYPE_rev_lookup, tmp, tmp2);
  Py_DECREF(tmp);
  Py_DECREF(tmp2);

 tmp = PyLong_FromLong(REG_SZ);
  tmp2 = PyString_FromString("REG_SZ");
  PyDict_SetItem(REGFI_DATA_TYPE_Dict_lookup, tmp2, tmp);
  PyDict_SetItem(REGFI_DATA_TYPE_rev_lookup, tmp, tmp2);
  Py_DECREF(tmp);
  Py_DECREF(tmp2);

 tmp = PyLong_FromLong(REG_EXPAND_SZ);
  tmp2 = PyString_FromString("REG_EXPAND_SZ");
  PyDict_SetItem(REGFI_DATA_TYPE_Dict_lookup, tmp2, tmp);
  PyDict_SetItem(REGFI_DATA_TYPE_rev_lookup, tmp, tmp2);
  Py_DECREF(tmp);
  Py_DECREF(tmp2);

 tmp = PyLong_FromLong(REG_BINARY);
  tmp2 = PyString_FromString("REG_BINARY");
  PyDict_SetItem(REGFI_DATA_TYPE_Dict_lookup, tmp2, tmp);
  PyDict_SetItem(REGFI_DATA_TYPE_rev_lookup, tmp, tmp2);
  Py_DECREF(tmp);
  Py_DECREF(tmp2);

 tmp = PyLong_FromLong(REG_DWORD);
  tmp2 = PyString_FromString("REG_DWORD");
  PyDict_SetItem(REGFI_DATA_TYPE_Dict_lookup, tmp2, tmp);
  PyDict_SetItem(REGFI_DATA_TYPE_rev_lookup, tmp, tmp2);
  Py_DECREF(tmp);
  Py_DECREF(tmp2);

 tmp = PyLong_FromLong(REG_DWORD_LE);
  tmp2 = PyString_FromString("REG_DWORD_LE");
  PyDict_SetItem(REGFI_DATA_TYPE_Dict_lookup, tmp2, tmp);
  PyDict_SetItem(REGFI_DATA_TYPE_rev_lookup, tmp, tmp2);
  Py_DECREF(tmp);
  Py_DECREF(tmp2);

 tmp = PyLong_FromLong(REG_DWORD_BE);
  tmp2 = PyString_FromString("REG_DWORD_BE");
  PyDict_SetItem(REGFI_DATA_TYPE_Dict_lookup, tmp2, tmp);
  PyDict_SetItem(REGFI_DATA_TYPE_rev_lookup, tmp, tmp2);
  Py_DECREF(tmp);
  Py_DECREF(tmp2);

 tmp = PyLong_FromLong(REG_LINK);
  tmp2 = PyString_FromString("REG_LINK");
  PyDict_SetItem(REGFI_DATA_TYPE_Dict_lookup, tmp2, tmp);
  PyDict_SetItem(REGFI_DATA_TYPE_rev_lookup, tmp, tmp2);
  Py_DECREF(tmp);
  Py_DECREF(tmp2);

 tmp = PyLong_FromLong(REG_MULTI_SZ);
  tmp2 = PyString_FromString("REG_MULTI_SZ");
  PyDict_SetItem(REGFI_DATA_TYPE_Dict_lookup, tmp2, tmp);
  PyDict_SetItem(REGFI_DATA_TYPE_rev_lookup, tmp, tmp2);
  Py_DECREF(tmp);
  Py_DECREF(tmp2);

 tmp = PyLong_FromLong(REG_RESOURCE_LIST);
  tmp2 = PyString_FromString("REG_RESOURCE_LIST");
  PyDict_SetItem(REGFI_DATA_TYPE_Dict_lookup, tmp2, tmp);
  PyDict_SetItem(REGFI_DATA_TYPE_rev_lookup, tmp, tmp2);
  Py_DECREF(tmp);
  Py_DECREF(tmp2);

 tmp = PyLong_FromLong(REG_QWORD);
  tmp2 = PyString_FromString("REG_QWORD");
  PyDict_SetItem(REGFI_DATA_TYPE_Dict_lookup, tmp2, tmp);
  PyDict_SetItem(REGFI_DATA_TYPE_rev_lookup, tmp, tmp2);
  Py_DECREF(tmp);
  Py_DECREF(tmp2);

 tmp = PyLong_FromLong(REG_KEY);
  tmp2 = PyString_FromString("REG_KEY");
  PyDict_SetItem(REGFI_DATA_TYPE_Dict_lookup, tmp2, tmp);
  PyDict_SetItem(REGFI_DATA_TYPE_rev_lookup, tmp, tmp2);
  Py_DECREF(tmp);
  Py_DECREF(tmp2);

};
python_wrappers[TOTAL_CLASSES].class_ref = (Object)&__ValueIterator;
python_wrappers[TOTAL_CLASSES++].python_type = &ValueIterator_Type;
python_wrappers[TOTAL_CLASSES].class_ref = (Object)&__DWORDData;
python_wrappers[TOTAL_CLASSES++].python_type = &DWORDData_Type;
}

