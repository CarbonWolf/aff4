import os, shutil, sys, subprocess, re
Import('env') # exported by parent SConstruct

dpkg_arch = subprocess.Popen(['dpkg-architecture'], stdout=subprocess.PIPE).communicate()[0]
dpkg_conf = dict(
    DEB_NAME = "libaff4",
    DEB_VERSION = "0.01",
    DEB_MAINT = "scudette@gmail.com",
    DEB_BUILD_ARCH = "i386",
    DEB_DEPENDS = "openssl", # what are we dependent on?
    DEB_DESC = "The advanced forensics file format v4 (AFF4)",
    hg_version = '',
    )

for line in dpkg_arch.splitlines():
    k, v = line.split("=",1)
    dpkg_conf[k]=v

## Grab the revision version from hg
hg_output = subprocess.Popen(["hg", "tip"], stdout=subprocess.PIPE).communicate()[0]
m = re.search(r"changeset:\s+(\d+)", hg_output)
if m:
    dpkg_conf['DEB_VERSION'] += "_rev_" + m.group(1)

DEB_FILES = [
    # Now we specify the files to be included in the .deb
    # Where they should go, and where they should be copied from.
    # If you have a lot of files, you may wish to generate this 
    # list in some other way.
    ("usr/lib/libaff4.so",   "#lib/libaff4.so"),
    ("usr/lib/libaff4.so.0", "#lib/libaff4.so.0"),
    ("usr/include/aff4.h",  "#include/aff4.h"),
]

# This is the debian package we're going to create
debpkg = '#%(DEB_NAME)s_%(DEB_VERSION)s_%(DEB_BUILD_ARCH)s.deb' % dpkg_conf

# and we want it to be built when we build 'debian'
env.Alias("debian", debpkg)

DEB_CONTROL_FILE = os.path.join(dpkg_conf['DEB_NAME'], "DEBIAN/control")

# This copies the necessary files into place into place.
# Fortunately, SCons creates the necessary directories for us.
for f in DEB_FILES:
    # We put things in a directory named after the package
    dest = os.path.join(dpkg_conf['DEB_NAME'], f[0])
    # The .deb package will depend on this file
    env.Depends(debpkg, dest)
    # Copy from the the source tree.
    env.Command(dest, f[1], Copy('$TARGET','$SOURCE'))
    # The control file also depends on each source because we'd like
    # to know the total installed size of the package
    env.Depends(DEB_CONTROL_FILE, dest)

# Now to create the control file:

CONTROL_TEMPLATE = """
Package: %(DEB_NAME)s
Priority: extra
Section: misc
Installed-Size: %(installed_size)s
Maintainer: %(DEB_MAINT)s
Architecture: %(DEB_BUILD_ARCH)s
Version: %(DEB_VERSION)s
Depends: %(DEB_DEPENDS)s
Description: %(DEB_DESC)s

"""
env.Depends(debpkg,DEB_CONTROL_FILE )

# The control file should be updated when the SVN version changes
env.Depends(DEB_CONTROL_FILE, env.Value(dpkg_conf['hg_version']))

# This function creates the control file from the template and info
# specified above, and works out the final size of the package.
def make_control(target=None, source=None, env=None):
    dpkg_conf['installed_size'] = 0
    for i in DEB_FILES:
        dpkg_conf['installed_size'] += os.stat(str(env.File(i[1])))[6]
    control_info = CONTROL_TEMPLATE % dpkg_conf
    f = open(str(target[0]), 'w')
    f.write(control_info)
    f.close()

# We can generate the control file by calling make_control
env.Command(DEB_CONTROL_FILE, None, make_control)

# And we can generate the .deb file by calling dpkg-deb
env.Command(debpkg, DEB_CONTROL_FILE,
            "fakeroot dpkg-deb -b %s %s" % ("deb/%s" % dpkg_conf['DEB_NAME'], "$TARGET"))
